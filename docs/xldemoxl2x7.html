<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=0.9, user-scalable=no">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/Mischlichter/data/main/gallerycom/65411740980.jpg">
    <meta http-equiv="Cache-Control" content="public, max-age=31536000">
    
    <meta name="description" content="Transform your words into stunning visual artworks with HogeAI.">
    <meta name="keywords" content="AI art, HogeAI, Text-to-image generation, Digital creativity, Creative community, Visual storytelling, AI-powered creativity, Artistic AI tools, AI bot, Telegram bot, AI-driven art, Community-driven AI, AI illustrations, Creative AI, Digital art tools, Meme creation, Image generation, AI innovation, Artistic collaboration, AI models, Generative art, AI technology, AI training, Digital illustration, Visual art creation, AI research, AI in art, Creative tools, AI-generated images, Artistic expression, AI visualizations, AI for artists, Creative processes, AI applications, Digital content creation, AI art projects, AI content generation, AI development, Creative exploration, AI tools for artists, Digital creativity tools, AI-powered visuals, Artistic innovation, AI-driven creativity, Visual storytelling tools, AI in creative industries, Community art projects, AI and digital art, AI-generated art, Digital art community, AI image synthesis, AI art community, Creative AI solutions, Visual content creation, AI for creative expression, AI bot for art, AI art experiments, Digital art platform, AI-powered art tools, Visual art innovation, AI in visual arts, Creative AI community, Hoge, Hoge memes, Hoge community, Digital art generation, AI art collaboration, Visual creativity, AI-driven visuals, AI art creation, Creative AI research, Digital art and AI, AI-powered creativity tools, Artistic AI projects, AI in creative processes, Visual storytelling with AI, AI and digital creativity, AI art bot on Telegram, AI and artistic expression, Community-driven art, AI for digital artists, Visual art and AI, AI and visual storytelling, AI art initiatives, Digital art with AI, Creative AI initiatives, Visual content and AI, AI for creative communities, AI-generated visuals, AI art bot features, AI-driven art projects, Digital creativity with AI, Artistic AI models, AI image generation tools, Community-driven creativity, AI and digital art tools, Visual art tools with AI, AI-powered content creation, Digital illustration with AI, AI in creative industries, AI and visual content, Artistic AI research, AI for visual artists, Digital art tools with AI, AI-generated illustrations, AI and digital storytelling, Creative AI technologies, Visual storytelling and AI, AI for creative innovation, AI art collaborations, Digital art community projects, AI-powered artistic tools, AI and visual art creation, AI in digital content creation, Hoge character, Community engagement, Artistic inspiration, Creative experimentation, User-generated content, Visual art projects, Artistic challenges, Art sharing platform, AI-generated memes, Hoge-inspired art, Custom AI models, AI training data, Collaborative art creation, Hoge community support, Art galleries, Visual art showcase, Community creativity, Creative expression, Artistic freedom, Visual storytelling community, AI art competitions, Art and technology, Creative innovation, Art creation journey, AI art exploration, User creativity, Community art events, Art workshops, Creative collaboration, Art and AI integration, Artistic growth, Art community support, Visual art techniques, AI art tutorials, Artistic mentorship, Digital art workshops, AI art resources, Creative art sessions, Art community engagement, Collaborative art projects, Community-driven innovation, Art creation tools, AI-powered art techniques, Community feedback, Art platform features, User art contributions, Community art inspiration, Art sharing guidelines, Art showcase platform, Collaborative art features, Community-driven features, Art platform updates, User art galleries, Community art showcase, Art creation inspiration, AI art updates, Community art challenges, Art creation support, AI art sharing, Community engagement features, Art creation tutorials, AI art mentorship, Visual art community support, Art creation feedback, Creative platform features, AI art events, Community art collaborations, Art creation inspiration, AI art techniques, Visual art feedback, Community art resources, Art creation challenges, AI art support, Visual art community, Art platform innovations, User-driven art projects, Community art inspiration, Art creation resources, AI art collaboration, Visual art creation tools, Art community projects, AI art platform, Community-driven art platform, User art events, Community-driven art projects, Visual art creation features, Art platform updates, AI art features, Community art events, User art engagement, Art creation ideas, AI art platform updates, Visual art collaboration, Art community innovations, AI art project ideas, Community art collaboration features, User-driven art platform, Art creation feedback, AI art engagement, Visual art project updates, Art platform collaboration, Community art creation features">

    <meta property="og:title" content="HogeAI">
    <meta property="og:description" content="Transform your words into stunning visual artworks.">
    <meta property="og:image" content="https://raw.githubusercontent.com/Mischlichter/data/main/Viewer/HogeAI_00034_.png">
    <meta property="og:url" content="http://www.HogeAI.com">
    <meta property="og:type" content="website">
    <meta property="og:site_name" content="HogeAI">
    <meta property="og:locale" content="en_US">
    
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="HogeAI">
    <meta name="twitter:description" content="Transform your words into stunning visual artworks.">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/Mischlichter/data/main/Viewer/HogeAI_00034_.png">
        
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#000000">
    <meta name="msapplication-TileColor" content="#000000">
    <meta name="theme-color" content="#000000">

    <link rel="preconnect" href="https://raw.githubusercontent.com">
    <link rel="preconnect" href="https://kit.fontawesome.com">   

    <link rel="dns-prefetch" href="https://raw.githubusercontent.com">

    <meta name="referrer" content="no-referrer">
    <meta name="robots" content="index, follow">
    
    
    <title>HogeAI</title>


<style>
    
    @font-face {
        font-family: 'JetBrainsMono-Regular';
        src: url('https://www.hogeai.com/fonts/JetBrainsMono-Regular.woff2') format('woff2'), /* Modern Browsers */
             url('https://www.hogeai.com/fonts/JetBrainsMono-Regular.ttf') format('truetype'); /* Safari, Android, iOS */
        font-weight: 400; /* Regular font weight */
        font-style: normal;
        font-display: block;
    }

    @font-face {
        font-family: 'JetBrainsMono-Bold';
        src: url('https://www.hogeai.com/fonts/JetBrainsMono-Bold.woff2') format('woff2'), /* Modern Browsers */
             url('https://www.hogeai.com/fonts/JetBrainsMono-Bold.ttf') format('truetype'); /* Safari, Android, iOS */
        font-weight: 700; /* Bold font weight */
        font-style: normal;
        font-display: block;
    }

    @font-face {
        font-family: 'JetBrainsMono-BoldItalic';
        src: url('https://www.hogeai.com/fonts/JetBrainsMono-BoldItalic.woff2') format('woff2'), /* Modern Browsers */
             url('https://www.hogeai.com/fonts/JetBrainsMono-BoldItalic.ttf') format('truetype'); /* Safari, Android, iOS */
        font-weight: 700; /* Bold font weight */
        font-style: italic;
        font-display: block;
    }

    @font-face {
        font-family: 'JetBrainsMono-ExtraBold';
        src: url('https://www.hogeai.com/fonts/JetBrainsMono-ExtraBold.woff2') format('woff2'), /* Modern Browsers */
             url('https://www.hogeai.com/fonts/JetBrainsMono-ExtraBold.ttf') format('truetype'); /* Safari, Android, iOS */
        font-weight: 800; /* Extra-bold font weight */
        font-style: normal;
        font-display: block;
    }



    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        -webkit-font-smoothing: antialiased;
        
        -moz-osx-font-smoothing: grayscale;
        font-family: 'JetBrainsMono-Regular', sans-serif;
        background-color: black;
        color: #00ffcc;
        margin: 0;
        padding: 0;
        transition: color 0.3s ease;
        max-width: 100vw;
        overflow-x: hidden; /* Prevent horizontal scrolling */
        touch-action: pan-y; /* Allow vertical panning, disable everything else */
        -webkit-user-select: none; /* Prevent text selection */
        -ms-user-select: none;
        user-select: none;
        
    }


    html {
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        
        
    }

    html, body {
        /*background-color: black;*/
        color: #00ffcc; /* Green color */
        /*height: 100vh;*/
        margin: 0;
        padding: 0;
    
    
        scrollbar-width: none;
        scrollbar-color: transparent transparent;
        
    }

    body::-webkit-scrollbar {
        width: 12px;
    }

    body::-webkit-scrollbar-track {
        background: transparent;
        border-left: 6px solid transparent; /* Adjust the border width to match the thumb's width */
    }

    body::-webkit-scrollbar-thumb {
        background: transparent;
        pointer-events: none; /* Disable interactivity */
    }

    #iframeContainer {
        width: 100%;
        height: 100%;
        z-index: 1;
        position: relative;

        
    }
    #mouseOverlay {
        pointer-events: auto;
        z-index: 1;

    }

    #iframeContainer iframe {
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index:1;
    }

    @media (orientation: portrait) {
        #iframeContainer iframe {
            transform: scale(0.9);
        }
    }

    /* Ensure the iframe is at normal size when in landscape mode */
    @media (orientation: landscape) {
        #iframeContainer iframe {
            transform: scale(1.0);
        }
    }
    
    /* Individual image containers */
    .flex-icontainer {
    
         /* Smooth fade-in transition */
        position: relative; /* Essential for absolute child positioning */
        padding-top: 38%; /* Same as width for a 1:1 aspect ratio */
        margin: 50px auto; /* Center horizontally */
        border: 2px solid #00ffcc; /* Green border */
        border-radius: 20px; /* Rounded corners */
        overflow: hidden; /* Ensures nothing spills outside the rounded corners */
        box-sizing: border-box;
        background-color: black;
        pointer-events: none;
        touch-action: none;

    }

    .flex-icontainer img {
        position: absolute;
        top: 50%;
        left: 50%;
        width: 100%; /* Ensure the image covers the container */
        height: 100%;
        transform: translate(-50%, -50%); /* Center the image */
        object-fit: cover; /* Ensure the image covers the container */
        pointer-events: none;
        touch-action: none;
    }

    .flex-container {
        display: flex;
        flex-wrap: wrap;
        margin: 50px auto; /* Center horizontally */
        /*position: relative;
        bottom: 800px; */
        border: none;
        box-sizing: border-box;
        font-family: 'JetBrainsMono-Bold', sans-serif;
        text-transform: uppercase;
       
        z-index: 2;
    
        border: 2px solid #00ffcc; /* Green border */
        border-radius: 20px; /* Rounded corners */
        padding: 8px 15px; /* Adjust padding as needed */
        background-color: black;
       
     
    }
    
    .flex-container span {
        white-space: nowrap;
        display: inline-block;
        margin: 0 5px 5px 0;
        pointer-events: none;

        
        
    }

    #mainpage .dynamic-text { 
        opacity: 0;
        pointer-events: none;
        
    }

    
    #bodygallery .dynamic-text {
        z-index: 2;
        pointer-events: none;
    }
        
    .menu-bar {
        display: flex;
        justify-content: space-evenly; /* Evenly spaces the menu items */
        align-items: center;
        background-color: black; /* 20% grey color */
        border: 2px solid #00ffcc;
        border-radius: 20px;
        position: fixed; /* Fixed to the top */
        top: 0;
        left: 0;
        width: 100%;
        padding: 10px 30px;
        box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
        z-index: 1000; /* Ensures it stays on top of other content */
    }

    /* General styles for the menu container */
    .menu-container {
        font-family: 'JetBrainsMono-Bold';
        font-size: 16px;
        margin: 0; /* Adjust as needed */
        cursor: default; /* Or 'pointer' if you want a hand cursor */
        user-select: none;
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none;
    }

    /* Active menu item */
    .active-menu-item {
        font-family: 'JetBrainsMono-Bold'; /* Bold font */
        color: #fff; /* Change color if needed */
    }

    /* Hover effect */
    .menu-container:hover {
        transform: scale(1.1); /* Slightly enlarges the hovered item */
    }

    /* .logo-small class will be toggled dynamically by JS */
    .logo-small {
        position: absolute;
        left: 13.5%;
        top: 50%;
        transform: translate(-50%, -50%);
    }


    .active-menu-item {
        font-family: 'JetBrainsMono-Bold'; /* Bold font */
        color: #fff; /* Change color if needed */
        /* Other styles to highlight the active item */
    }
    .menu-container {
        transition: transform 0.3s ease;
    }
    .menu-container:hover {
        transform: scale(1.1); /* Slightly enlarges the hovered item */
    }
    .content-above-iframe {
        padding: 20px;
    }
    .content-below-iframe {
        padding: 20px;
    }

    .foreground-image-container {
        position: absolute; /* or absolute, depending on your layout needs */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1; /* Ensures it is above all other content */
        pointer-events: none; /* Allows clicks to pass through to elements below */
    }

    .foreground-image {
        width: 100%;
        height: 100%;
        object-fit: cover; /* Adjust this as necessary to fit your design */
    }

    :root {
        --viewer-width: 1024px;
        --viewer-height: 2048px;
        --total-width: 3072px; /* New variable for total width */
    }

    #interfaceContainer {
        position: absolute; /* or 'fixed' depending on use case */
        top: 50%;
        left: 50%;
        z-index: 15;
        transform: translate(-50%, -50%);
        width: var(--total-width); /* Assuming this is set to 3072px or as needed */
        height: var(--viewer-height); /* Assuming this is set to 2048px */
        margin: 0 auto; /* Center the container */
        
        pointer-events: none;
    }

    .sideImageContainer {
        background-size: cover;
        background-repeat: no-repeat;
        z-index: 15;
        
    }

    #interfaceSideLeft, #interfaceSideRight {
        position: absolute;
        top: 0;
        width: calc((var(--total-width) - var(--viewer-width)) / 2); /* Adjust width for side containers */
        height: 100%;
        
    }

    #interfaceSideLeft {
        left: 0;
        
    }

    #interfaceSideRight {
        right: 0;
        
    }

    #interfaceViewerContainer {
        position: absolute;
        top: 0;
        left: calc((100% - var(--viewer-width)) / 2); /* Center the viewer */
        width: var(--viewer-width);
        height: 100%;
        z-index: 15;
        display: flex;
        justify-content: center;
        align-items: center;
        pointer-events: none;
        
    }

    #interfaceViewerImage {
        width: 100%;
        height: 100%;
        pointer-events: none;
        
    }

    :root {
        --background-total-width: 4096px;
        --background-total-height: 3072px;
    }

    #backgroundRoot {
        --viewer-width: 1024px;
        --viewer-height: 2048px;
        --total-width: 3072px; /* New variable for total width */
    }

    #backgroundContainer {
        position: absolute; /* or 'fixed' depending on use case */
        top: 50%;
        left: 50%;
        z-index: -2;
        transform: translate(-50%, -50%);
        width: var(--total-width); /* Assuming this is set to 3072px or as needed */
        height: var(--viewer-height); /* Assuming this is set to 2048px */
        margin: 0 auto; /* Center the container */
        
    }

    #backgroundInterfaceContainer {
        position: absolute;
        top: 1096px;
        left: calc((100% - var(--viewer-width)) / 2); /* Center the viewer */
        width: var(--viewer-width);
        height: 100%;
        z-index: -2;
        display: flex;
        justify-content: center;
        align-items: center;
       
    }

    #interfaceBackground {
        width: 100%;
        height: auto;
        
    }

    .scale-wrapper-background, .scale-wrapper-interface {
        position: absolute; /* Or 'fixed' if they should stay in place during scroll */
        top: 0;
        left: 0;
        width: 100%;
        height: 100%; /* Or an explicit height if necessary */
        pointer-events: none; /* To allow interaction with elements below */
    }

    .scale-wrapper-background {
        pointer-events: none;
        position: absolute; /* Switched to absolute for stronger positioning control */
        top: -15%;
        left: 50%;
        transform-origin: center center; /* Ensures scaling occurs from the element's center */
        width: fit-content; /* Ensures the wrapper fits the scaled content */
        height: fit-content; /* Ensures the wrapper fits the scaled content */
        transform: translate(-50%, -50%) scale(0.8); /* Centers and then scales the content */
        
    }

    .scale-wrapper-interface {
        pointer-events: none;
        position: absolute; /* Switched to absolute for stronger positioning control */
        top: 50%;
        left: 50%;
        transform-origin: center center; /* Ensures scaling occurs from the element's center */
        width: fit-content; /* Ensures the wrapper fits the scaled content */
        height: fit-content; /* Ensures the wrapper fits the scaled content */
        transform: translate(-50%, -50%) scale(0.8); /* Centers and then scales the content */
        
    }

    .scale-wrapper-background {
        z-index: -2; /* Ensures the background is placed behind other content */
    }

    .scale-wrapper-interface {
        z-index: 15; /* Ensures the interface is placed above the background */
    }

    #interfaceContainer, #backgroundContainer, #iframeContainer, #bodyGalleryContainer, .flex-icontainer, .flex-container {
        transition: opacity 1s ease-in-out;
        opacity: 0;  /* Initially hidden, ensure this is your intent */
        
    }

    .menu-bar, .menu-container {
        transition: opacity 0.5s ease-in-out;
        opacity: 0;  /* Initially hidden, ensure this is your intent */
        
    }




    .center-container-XL {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 1000vh;
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 70;
        background-color: rgba(0, 0, 0, 0);
        transition: opacity 1.5s ease-out; /* Smooth transition for opacity */
    }

    #ascii-art-container-XL {
        width: 370px;
        height: 170px;
        overflow: hidden;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        z-index: 3;
        font-size: 16px;
    }

    .ascii-line-XL {
        white-space: pre;
        font-family: monospace;
        color: #00ffcc;
        transition: opacity 1s ease-out;

    }

    .hidden-char-XL {
        visibility: hidden;
    }


    #permissionOverlay {
        width: 100%;
        height: 100%;
        position: fixed;
        top: 0;
        left: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.5);
        opacity: 0; 
        visibility: hidden;
        transition: opacity 0.5s ease-in-out; 
        z-index: 1111111;
    }




    #enableButton {
        padding: 10px 20px;
        font-family: 'JetBrainsMono-Bold';  /* Consistent with the menu */
        font-size: 16px;                    /* Size from the menu */
        background-color: black;            /* Background color like the menu */
        color: #00ffcc;                     /* Highlight color for the text, matching the menu border */
        border: 2px solid #00ffcc;          /* Border color to match the menu */
        border-radius: 20px;                /* Rounded corners like the menu */
        cursor: pointer;
        outline: none;
        z-index: 1111111;
        position: relative;                 /* Ensure positioning context is correct */
        top: auto;
        left: auto;
        width: auto;                        /* Auto width to fit content */
        box-shadow: 0px 4px 8px rgba(0, 0, 0); /* Slight shadow for depth */
        opacity: 0;
        visibility: hidden;
    }


    html.lenis, html.lenis body {
      height: auto;
    }

    .lenis.lenis-smooth {
      scroll-behavior: auto !important;
    }

    .lenis.lenis-smooth [data-lenis-prevent] {
      overscroll-behavior: contain;
    }

    .lenis.lenis-stopped {
      overflow: hidden;
    }

    .lenis.lenis-smooth iframe {
      pointer-events: none;
    }

    /* Add this CSS to your stylesheet */
    .no-scroll {
        overflow: hidden;
    }





    /*GALLERYINJECTION*/




    #bodygallery {
        
        font-family: 'JetBrainsMono-Bold', sans-serif;
       
        background-color: black;
        color: #00ffcc; /* Green color */
        margin: 0;
        padding: 0;
        overflow: auto;

    }

    .centered-container {
        display: none; /* Hide the centered-container initially */

    /* other styles... */
    }


    .hover-effect-wrapper {
        max-width: 100%;
        max-height: 100vh;
        position: relative;
        /* Preserving aspect ratio (1:1 in this case) */
        width: 100vmin;
        height: 100vmin;
        margin: auto; /* Centering the wrapper */
        z-index: 1

    }  
    .square-aspect-ratio .hover-effect-wrapper {
        top: -100vh;
        position: absolute;

    }



    .hover-effect-container {
        width: 100%;
        height: 100%;
        position: absolute;
        left: 0;
        z-index: 1;
    }



    .square-aspect-ratio .hover-effect-container {
        top: 107vh;        /* Adjust this value for space from the top */
        left: 0;
        right: 0;
        width: 100%;

    }

    .fade-out {
        animation: fadeOut 0.555s forwards;
    }

    @keyframes fadeOut {
        to { opacity: 0; }
    }





    .btn-nav {
        position: absolute;
        top: 50%;
        transform: translateY(-50%);
        
        border: none;
        cursor: pointer;
        padding: 10px;
        font-size: 24px;
        border-radius: 50%;
        opacity: 0.7;
        z-index: 5010;
        color: white


    }

    #btn-prev { 
        left: 30px;
        font-size: 42px;
        user-select: none;
        z-index: 11010;
    }
    #btn-next { 
        right: 30px;
        font-size: 42px;
        user-select: none;
        z-index: 11010;
    }



    #button-overlay {
        position: fixed; /* Fixed positioning */
        top: 65px; /* Fixed space from the top */
        left: 50%; /* Centered horizontally */
        transform: translateX(-50%); /* Adjust horizontal centering */
        max-width: 1024px; /* Maximum width */
        max-height: 1024px; /* Maximum height, same as width for square shape */
        width: 100vmin; /* Responsive width, 80% of the viewport's smaller dimension */
        height: 100vmin; /* Responsive height, same as width */
        z-index: 1111010; /* Above other elements */
        display: flex; /* Flexbox for inner alignment */
        justify-content: center; /* Centering horizontally */
        align-items: center; /* Centering vertically */
        pointer-events: none; /* Allows click-through */
        
    }

    #button-overlay > .btn-nav {
        pointer-events: auto; /* Button interactions enabled */
    }






    .close {
        position: absolute;
        top: 10px;
        right: 20px;
        font-size: 30px;
        color: white;
        cursor: pointer;
        z-index: 1010;
        user-select: none;
    }

    .button-container {
        position: absolute;
        top: 20px; /* Adjust the top position as needed */
        left: 20px; /* Adjust the left position as needed */
        z-index: 1010;
    }

    /* Toggle Button Styles */
    .toggle-button {
        cursor: pointer;
        font-family: 'JetBrainsMono-Bold', sans-serif;
        font-size: 14px; /* Adjust font size as needed */
        color: white; /* White font color */
        user-select: none;
    }

    .image-wrap {
        position: relative;
        width: 100%; /* This will be relative to the grid column width */
        padding-top: 100%; /* This creates a square aspect ratio */
        overflow: hidden;
        cursor: pointer;
    }

    .image-wrap canvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        border-radius: 8px;
        object-fit: cover; /* Adjust this as needed */
    }

    .center-container {
        top: -10%;

        position: absolute; /* Use absolute positioning */
        width: 100%; /* Full width of the viewport */
        height: 10000%; /* Full viewport height */
        display: flex; /* Use flexbox for centering */
        justify-content: center; /* Center horizontally */
        align-items: center; /* Center vertically */
        z-index: 70; /* Place the center-container above the gallery container */
        background-color: rgba(0, 0, 0, 1); /* Semi-transparent black background */
    }

    #ascii-art-container {
        width: 370px;
        height: 170px;
        overflow: hidden;
        position: fixed; /* Use fixed positioning */
        top: 50%; /* Position from the center vertically */
        left: 50%; /* Position from the center horizontally */
        transform: translate(-50%, -50%); /* Center the element */
        z-index: 3; /* Place the ascii-art-container above the center-container */
        /* Rest of your styles for #ascii-art-container */
    }

    #ascii-art-container {

            font-size: 16px;

    }

    .ascii-line {
        white-space: pre;
        font-family: monospace;
        color: #00ffcc;
    }

    .hidden-char {
        visibility: hidden;
    }


    .no-scroll-keys {
        overflow: hidden;
    }

    #search-container {
        display: flex;
        justify-content: center;
        margin-top: 97px; /* Default top margin */
        margin-bottom: 30px; /* Bottom margin */
    }

    @media screen and (orientation: portrait) {
        #search-container {
            margin-top: 120px; /* Increased top margin for portrait mode */
        }
    }

    @media screen and (orientation: landscape) {
        #search-container {
            margin-top: 97px; /* Reduced top margin for landscape mode */
        }
    }

    #notification-popup {
        position: fixed; /* Keeps the notification at a fixed point on the screen */
        bottom: 50%; /* Distance from the bottom */
        left: 50%; /* Center horizontally */
        transform: translateX(-50%); /* Adjust horizontal centering */
        font-family: 'JetBrainsMono-Bold', sans-serif;
        font-size: 16px;
        border: 2px solid #00ffcc; /* Styled border */
        border-radius: 20px; /* Rounded corners */
        padding: 8px 15px;
        background: rgba(0, 0, 0, 0.7);
        color: #00ffcc;
        text-align: center;
        z-index: 5000; /* Makes sure the popup is on top */
        display: none; /* Start with hidden */
        opacity: 0; /* Start transparent */
        transition: opacity 0.5s ease-in-out;
    }

    #notification-popup2 {
        position: fixed; /* Keeps the notification at a fixed point on the screen */
        bottom: 50%; /* Distance from the bottom */
        left: 50%; /* Center horizontally */
        transform: translateX(-50%); /* Adjust horizontal centering */
        font-family: 'JetBrainsMono-Bold', sans-serif;
        font-size: 16px;
        border: 2px solid #00ffcc; /* Styled border */
        border-radius: 20px; /* Rounded corners */
        padding: 8px 15px;
        background: rgba(0, 0, 0, 0.7);
        color: #00ffcc;
        text-align: center;
        z-index: 5000; /* Makes sure the popup is on top */
        display: none; /* Start with hidden */
        opacity: 0; /* Start transparent */
        transition: opacity 0.5s ease-in-out;
    }

    #search-bar {
        font-family: 'JetBrainsMono-Bold', sans-serif; /* Use the custom font */
        font-size: 16px; /* Adjust as needed */
        border: 2px solid #00ffcc; /* Green border */
        border-radius: 20px; /* Rounded corners */
        padding: 8px 15px; /* Adjust padding as needed */
        outline: none; /* Removes the default focus outline */
        transition: border-color 0.3s;
        background-color: black; /* Matches the body background */
        color: #00ffcc; /* Green text color */
        width: 50%; /* Adjust width as needed */
    }
    /* Add this CSS to your stylesheet */
    #search-bar {
      transition: opacity 0.5s ease-in-out;
      opacity: 0.5; /* Adjust based on your initial visibility requirement */
    }


    #search-bar::placeholder {
        color: rgba(0, 255, 204, 0.5); /* Light green placeholder */
    }

    #search-bar:focus {
        border-color: #fff; /* White color on focus */
    }

    /* Blinking cursor effect */
    @keyframes blink {
        0%, 100% { opacity: 1; }
        50% { opacity: 0; }
    }

    #search-bar:not(:focus)::placeholder {
        content: ''; /* Remove placeholder text when not focused */
        animation: blink 1s step-end infinite;
    }



    #gallery-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(187px, 1fr));
        gap: 20px;
        padding: 20px;
        transition: transform 0.3s ease;
    }

    #gallery-container img {
        width: 100%;
        height: auto;
        cursor: pointer;
        border-radius: 8px;
        border: 2px solid #00ffcc;
        transition: opacity 0.1s ease, transform 0.1s ease-out;
        position: relative;
        overflow: hidden;
        transform: translateZ(0); /* Enable GPU acceleration for images */
        backface-visibility: hidden; /* Help with performance for non-GPU */
        will-change: transform; /* Hint the browser that transform will change */
    }

    #gallery-container .image-container {
        position: relative;
        overflow: hidden;
        cursor: pointer;
        border-radius: 8px;
        transition: transform 0.3s ease; /* Added hover transition to the container */
        transform: translateZ(0); /* Enable GPU acceleration */
        backface-visibility: hidden; /* Help with performance for non-GPU */
        will-change: transform; /* Hint the browser that transform will change */
    }

    @media (hover: hover) and (pointer: fine) {
        #gallery-container .image-container:hover {
            transform: scale(1.11) translateZ(0); /* Apply both scale and GPU acceleration on hover */
            will-change: transform; /* Hint the browser that transform will change */
        }
    }

    .hidden-image {
        opacity: 0;
        pointer-events: none; /* Prevent interaction with hidden images */
        display: none;
    }

    .image-container {
        position: relative;
        overflow: hidden;
        transform: translateZ(0); /* Enable GPU acceleration */
        backface-visibility: hidden; /* Help with performance for non-GPU */
        will-change: transform; /* Hint the browser that transform will change */
    }


    .word-overlay {
        font-family: 'JetBrainsMono-ExtraBold', sans-serif;
        position: absolute;
        bottom: 10%; /* Adjust this value as needed for vertical positioning */
        left: 50%;
        transform: translateX(-50%); /* Center both horizontally and vertically */
        overflow: visible; /* Allows text to overflow outside of the container */
        white-space: nowrap; /* Prevents automatic line breaks */
        text-align: center;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
        color: #7cfc05; /* Text color */
        padding: 0px;
        /* No width set so it takes the width of its content */

    }



    .hidden-overlay {
        display: none;
    }

    #text-info {
        font-family: 'JetBrainsMono-Bold', sans-serif;
        position: absolute;
        width: 800px; /* Fixed width */
        height: auto; /* Fixed height */
        bottom: 3%;
        left: 50%;
        transform: translateX(-50%);
     
        color: white;
        text-align: center;
        z-index: 1010;
        background: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
        padding: 15px;
        border-radius: 8px;

        transition: opacity 0.5s ease-in-out;
        overflow: hidden; /* To handle content overflow */
        display: block;
        text-shadow: 2px 2px 3px rgba(0, 0, 0, 1);
        pointer-events: none; /* Ignore mouse events */
        user-select: none;

    }
    .square-aspect-ratio #text-info {
        width: 100%; /* Full width for square screens */
        max-width: 400px; /* You can adjust the maximum width as needed */
    }

    #text-info p {
        margin: 5px 0;
        font-size: 14px;
        /* Additional styling */
    }

    #text-prompt,
    #text-seed,
    #text-creator {
        display: inline-block;
        pointer-events: none;
        
    }

    #text-seed::before,
    #text-creator::before {
        content: "\A"; /* Add a line break before Seed and Creator */
        pointer-events: none;
        
    }

     #text-info2 {
        font-family: 'JetBrainsMono-Bold', sans-serif;
        position: absolute;
        width: 800px; /* Fixed width */
        height: auto; /* Fixed height */
        bottom: 3%;
        left: 50%;
        transform: translateX(-50%);
     
        color: rgba(0, 0, 0, 0.0000000001);
        text-align: center;
        z-index: 1010;
        background: rgba(0, 0, 0, 0.0000000001); /* Semi-transparent background */
        padding: 15px;
        border-radius: 8px;
        transition: opacity 0.3s ease-in-out;
        overflow: hidden; /* To handle content overflow */
        display: block;
        z-index: 2020
        margin: 5px 0;
        font-size: 14px;
    }
    #text-prompt2,
    #text-seed2,
    #text-creator2 {
        display: inline-block;
        
    }

    #text-seed2::before,
    #text-creator2::before {
        content: "\A"; /* Add a line break before Seed and Creator */
        
    }
    .square-aspect-ratio #text-info2 {
        width: 100%; /* Full width for square screens */
        max-width: 400px; /* You can adjust the maximum width as needed */
    }

    #text-info2 p {
        margin: 5px 0;
        font-size: 14px;
        /* Additional styling */
    }
    #loading-progress-container {
        position: absolute;
        top: 96px;
        right: 30px;
        width: 45px;
        height: 50px;
        transition: opacity 1s ease-out;
        opacity: 1;
        z-index: 50;
    }

    @media screen and (orientation: portrait) {
        #loading-progress-container {
            top: 118.5px; /* Increased top for portrait mode */
        }
    }

    @media screen and (orientation: landscape) {
        #loading-progress-container {
            top: 96px; /* Adjusted top for landscape mode */
        }
    }



    .circular-chart {
        display: block;
        max-width: 100%; /* Adjust if needed */
        max-height: 100%; /* Adjust if needed */
    }

    .circle-bg {
        fill: none;
        stroke: #000000;
        stroke-width: 1;
    }

    .circle {
        fill: none;
        stroke-width: 1.6;
        stroke-linecap: round;
        animation: progress 1s ease-out forwards;
    }

    @keyframes progress {
        0% {
            stroke-dasharray: 0 100;
        }
    }

    


    
</style>

</head>

<body>
    
    <div class="center-container-XL"> 
        <div id="ascii-art-container-XL">
        </div>
    </div>

    <div class="mainpage">
        
    <div id="permissionOverlay">
        <button id="enableButton">ENTER HOGEAI</button>
    </div>    

    </div>
        <div id="iframeContainer" style="position: relative; width: 100%; height: 100%;;z-index: 1;">
        <div id="mouseOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;z-index: 1;"></div>
 
    </div>

    <div id="bodyGalleryContainer">

    </div>
    
    <div class="scale-wrapper-background">
        <div id="backgroundRoot">
            <div id="backgroundContainer">
                <div id="backgroundInterfaceContainer">
                    <div id="interfaceBackground"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="scale-wrapper-interface">
        <div id="interfaceContainer">
            <div id="interfaceSideLeft" class="sideImageContainer"></div>
            <div id="interfaceViewerContainer">
                <img id="interfaceViewerImage" alt="Viewer Image">
            </div>
            <div id="interfaceSideRight" class="sideImageContainer"></div>
        </div>
    </div>
      
    </div>
    
    <script src="https://kit.fontawesome.com/a258000a2d.js" crossorigin="anonymous" defer></script>
    <script src="./scripts/index-min.js"></script>
    <script src="./scripts/lenis.min.js"></script>
    <script src="./scripts/three.min.js"></script>
    <script src="./scripts/gsap.min.js"></script>    
    <script src="./scripts/bodygallery.min.js"></script>
    
    
    <script>
        document.addEventListener("DOMContentLoaded",async function(){let b="firstLoadComplete",E="secondLoadComplete",I=0,o=(localStorage.getItem(b)&&!localStorage.getItem(E)&&(I=111),["                 /^ ^\\                ","                / 111 \\               ","                V\\ Y /V               ","                 / - \\                ","                /    |                ","               V__) ||                ","**************************************","**** LOADING HOGEAI WEBSITE FILES ****","**************************************"]);var e=document.createElement("div");e.style.position="absolute",e.style.top="0",e.style.left="0",e.style.width="100%",e.style.height="50000vh",e.style.zIndex="-2",e.style.backgroundColor="rgba(0, 0, 0, 0)",document.body.insertBefore(e,document.body.firstChild);let r=document.getElementById("ascii-art-container-XL"),n=o[0].length;o.forEach((e,t)=>{let n=document.createElement("div");n.className="ascii-line-XL",e.split("").forEach((e,t)=>{var o=document.createElement("span");o.setAttribute("data-original-char",e)," "!==e&&""!==e||o.classList.add("hidden-char-XL"),n.appendChild(o)}),r.appendChild(n),localStorage.getItem("firstLoadComplete")&&document.querySelectorAll(".ascii-line-XL").forEach(function(e){e.style.visibility="hidden"})});function i(){var e="ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*()[]{}|";return e.charAt(Math.floor(Math.random()*e.length))}function a(){return`hsl(${Math.floor(360*Math.random())}, 100%, 50%)`}let t=0,s=setInterval(function(){document.querySelectorAll(".ascii-line-XL").forEach(t=>{for(let e=0;e<n;e++){var o=t.childNodes[e];o&&(100===I?(o.textContent=o.getAttribute("data-original-char"),o.style.color="",o.classList.remove("hidden-char-XL")):e>=I&&e<I+7?(o.textContent=i(),o.style.color=a()):e>=I-7&&e<I&&(o.textContent=o.getAttribute("data-original-char"),o.style.color=""))}})},30);setInterval(function(){t<I&&(t=I),I++},1e5);let l=setInterval(function(){if(45<=I){{let r=Array.from(document.querySelectorAll("span")).filter(e=>"1"===e.getAttribute("data-original-char"));r.forEach((n,e)=>{setTimeout(()=>{{var o=n;r.length;let e=0,t=setInterval(()=>{11100<=e?(clearInterval(t),o.textContent="1",o.style.color=""):(o.textContent=i(),o.style.color=a(),e+=1e3/420)},1e3/420)}},50*e)})}clearInterval(l),clearInterval(s)}},10);async function c(){var e="indexedDB"in window?(console.log("This browser supports IndexedDB"),!0):(console.log("This browser does not support IndexedDB"),!1);console.log("Loading");let o;if(e)for(let t=1;t<=5;t++)try{o=await function(e,r){return new Promise((t,o)=>{let n=setTimeout(()=>{o(new Error("Timeout"))},r);e.then(e=>{clearTimeout(n),t(e)}).catch(e=>{clearTimeout(n),o(e)})})}(idb.openDB("MyDatabase",1,{upgrade(e,t,o,n){e.objectStoreNames.contains("assets")||e.createObjectStore("assets",{keyPath:"url"})}}),3e3);break}catch(e){if(console.error(`Error opening database on attempt ${t}:`,e),!(t<5)){o=null;break}await new Promise(e=>setTimeout(e,1e3))}let n;try{n=await caches.open("site-assets")}catch(e){return void console.error("Error opening cache:",e)}let t,r;try{[t,r]=await Promise.all([fetch("https://raw.githubusercontent.com/Mischlichter/data/main/index.json").then(e=>e.json()),fetch("https://raw.githubusercontent.com/Mischlichter/data/main/assets/pagesi.txt").then(e=>e.text())])}catch(e){return void console.error("Error fetching assets or extra assets:",e)}let i=[];!function t(o,n){for(var r in o)if(o.hasOwnProperty(r)&&(r.startsWith("Viewer")||r.startsWith("interface"))){let e=o[r];if("object"!=typeof e){let t=S(e);if(t){let e={url:"https://raw.githubusercontent.com/Mischlichter/data/main/"+r,lastModified:t.toISOString()};n.push(e)}else console.error("Failed to standardize date for key:",r,"value:",e)}else t(e,n)}}(t,i);var a=function(e,o){var n=[],e=e.split("\n");for(var r of e){r=r.trim();if(r.startsWith("https://")){let t=new URL(r).pathname.split("/").pop();var i,a=Object.keys(o).find(e=>e.endsWith(t));a?(a=o[a],(i=S(a))?(r={url:r,lastModified:i.toISOString()},n.push(r)):console.error("Invalid date for filename:",t,"value:",a)):console.log("No manifest entry found for filename: "+t)}}return n}(r,t);i.push(...a);let s=0;var l,c,d,u,m,h,f=[];for({url:l,lastModified:c}of i){let t=!0;if(e&&o)try{var g=await o.transaction("assets").objectStore("assets").get(l);g&&new Date(g.lastModified)>=new Date(c)&&(t=!1)}catch(e){console.error("Error checking IndexedDB for url:",l,e),t=!0}if(t)try{(h=await fetch(l)).ok?(d=h.clone(),await n.put(l,d),e&&o&&(u=await h.blob(),m=h.headers.get("last-modified")||new Date(c).toISOString(),f.push({url:l,blob:u,lastModified:m}))):console.error("HTTP error! Status: "+h.status)}catch(e){console.error("Error fetching url:",l,e)}s++,requestAnimationFrame(()=>{if(s<i.length)I=Math.floor(s/i.length*90);else{I=90;let o=performance.now(),n=1e3;requestAnimationFrame(function e(t){t-=o,t=Math.min(t/n,1);I=90+10*t,t<1?requestAnimationFrame(e):I=100})}}),await new Promise(e=>setTimeout(e,11))}if(e&&o)try{var y=f;try{var v,w=(await idb.openDB("MyDatabase",1,{upgrade(e,t,o,n){e.objectStoreNames.contains("assets")||e.createObjectStore("assets",{keyPath:"url"})}})).transaction("assets","readwrite"),p=w.objectStore("assets");for(v of y)await p.put({url:v.url,blob:v.blob,lastModified:v.lastModified});await w.done,console.log("All assets are stored in IndexedDB")}catch(e){console.error("Error storing assets in IndexedDB:",e)}await 0}catch(e){console.error("Error storing assets in IndexedDB:",e)}localStorage.getItem(b)||localStorage.setItem(b,"true"),localStorage.getItem(E)||localStorage.setItem(E,"true"),document.querySelectorAll(".ascii-line-XL").forEach(function(e){e.style.transition="opacity 1s ease-out",e.style.opacity="0"}),setTimeout(()=>{window.location.reload()},1111)}function S(e){var t=e.replace(" ","T")+"Z";let o=new Date(t);return!isNaN(o.getTime())||(t=e.match(/(\d{4})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})/))&&(o=new Date(`${t[1]}-${t[2]}-${t[3]}T${t[4]}:${t[5]}:${t[6]}Z`),!isNaN(o.getTime()))?o:(console.error("Unable to parse date:",e),null)}function d(){initialize();let e=document.querySelector(".center-container-XL");e?(e.style.opacity="0",setTimeout(()=>{e.style.display="none"},500)):console.error("Center container not found."),initializeMenu();var t=[...o];t[7]="***** WELCOME TO HOGEAI WEBSPACE *****",console.log(t.join("\n"))}let u=!1,m=0,h=32,f=0,g=0,y=0,v=0,w=!1,p=36,L=0,D=0,M=window.orientation||0,O=.7;function T(e){var t,o,n;u&&(t=Date.now())-m>h&&(m=t,t=window.innerWidth>window.innerHeight,o=window.orientation||0,w||(y=e.gamma,v=e.beta,w=!0),n=e.gamma-y,e=e.beta-v,t?90===o?(L=e*p,D=-n*p):-90!==o&&270!==o||(L=-e*p,D=n*p):(L=n*p,D=e*p),f+=(L-f)*O,g+=(D-g)*O,sendMouseEventToIframe("mousemove",{clientX:f,clientY:g}))}function A(){var e=document.getElementById("permissionOverlay");e?(e.style.opacity="0",setTimeout(()=>{e.style.visibility="hidden"},500)):console.log("Overlay not found.")}function B(){var e=document.getElementById("permissionOverlay"),o=document.getElementById("enableButton");e&&(e.style.visibility="visible",e.style.opacity="0",setTimeout(()=>e.style.opacity="1",10)),o&&(o.style.visibility="visible",o.style.opacity="0",setTimeout(()=>{var t;o.style.opacity="1",(t=document.getElementById("enableButton"))?(t.addEventListener("touchstart",function(e){e.preventDefault(),t.style.backgroundColor="lightblue"}),t.addEventListener("touchend",function(e){e.preventDefault(),t.style.backgroundColor="",A(),d(),"DeviceOrientationEvent"in window?"function"==typeof DeviceOrientationEvent.requestPermission?DeviceOrientationEvent.requestPermission().then(e=>{"granted"===e?window.addEventListener("deviceorientation",T,!0):console.error("Permission denied by user.")}).catch(e=>{console.error("Error requesting permission: "+e)}):window.addEventListener("deviceorientation",T,!0):console.error("Your device does not support gyroscope.")})):console.log("Enable button not found.")},10))}window.triggerOrientationWithoutCalibration=function(){w=!1},window.addEventListener("orientationchange",function(){var e=window.orientation||0;e!==M&&(w=!1,console.log("Orientation change detected. Recalibration required."),M=e)}),window.enableGyro=function(){u||(u=!0,window.addEventListener("deviceorientation",T,!0),console.log("Gyroscope Enabled"),requestAnimationFrame(()=>T({gamma:y,beta:v})))},window.disableGyro=function(){u&&(u=!1,window.removeEventListener("deviceorientation",T,!0),console.log("Gyroscope Disabled"))},localStorage.getItem(b)&&localStorage.getItem(E)?((/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)?B:(d(),A))(),localStorage.removeItem(b),localStorage.removeItem(E)):c()});
    </script>

    <script>
//////// MOUSE SMOOTHING ////////

        const isIOS = /iPad|iPhone|iPod/.test(navigator.platform) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) ||
                      /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                      ('ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0);

        const isGyroDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        let lastScrollY = 0;
        let lenisInitialized = false;
        let parallaxAnimationRegistered = false;
        let animateRegistered = false;
        let mouseEventListenersAdded = false;
        let savedState = null;
        let isPaused = false;
        let scrollAnimationFrame;
        let isScrolling = false;

        const AnimationManager = {
            frameCap: 60, // Increase frame cap for smoother animations
            lastRender: performance.now(),
            animations: [],
            running: false,

            registerAnimation(stepFunction) {
                if (!this.animations.includes(stepFunction)) {
                    this.animations.push(stepFunction);
                }
                if (!this.running) {
                    this.running = true;
                    requestAnimationFrame(this.runAnimations.bind(this));
                }
            },

            runAnimations(timestamp) {
                if (isPaused) return;
                let progress = timestamp - this.lastRender;
                if (progress > 1000 / this.frameCap) {
                    this.lastRender = timestamp - (progress % (1000 / this.frameCap));
                    this.animations = this.animations.filter(step => step(timestamp) !== false);
                }
                if (this.animations.length > 0) {
                    requestAnimationFrame(this.runAnimations.bind(this));
                } else {
                    this.running = false;
                }
            },

            cancelAnimations() {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                    this.animationFrameId = null;
                    this.running = false;
                }
            },

            pauseAnimations() {
                //console.log('Pausing animations');
                this.paused = true;
                this.running = false; // Stop the running loop
                this.saveState();
            },

            resumeAnimations() {
                if (this.paused) {
                    //console.log('Resuming animations');
                    this.paused = false;
                    this.restoreState();
                    if (!this.running && this.animations.length > 0) {
                        this.running = true;
                        requestAnimationFrame(this.runAnimations.bind(this));
                    }
                }
            },

            saveState() {
                try {
                    const state = {
                        lastRender: this.lastRender,
                        // Add any other state properties needed
                    };
                    localStorage.setItem('animationState', JSON.stringify(state));
                    //console.log('Animation state saved.');
                } catch (error) {
                    console.error('Error saving animation state:', error);
                }
            },

            restoreState() {
                try {
                    const state = JSON.parse(localStorage.getItem('animationState'));
                    if (state) {
                        this.lastRender = state.lastRender;
                        // Restore other animation-related state if needed
                        //console.log('Animation state restored.');
                    }
                } catch (error) {
                    console.error('Error restoring animation state:', error);
                }
            }
        };

        const lenisOptions = isIOS 
            ? { smoothTouch: true }  // Enable smoothTouch only for touch devices
            : { lerp: 0.042 };       // Use lerp for desktop

        // Initialize Lenis with the configured options
        const lenis = new Lenis(lenisOptions);

        lenis.on('scroll', () => {
            if (!parallaxAnimationRegistered) {
                parallaxAnimationRegistered = true;
                AnimationManager.registerAnimation(throttleUpdateParallax);
            }
            isScrolling = true;
            updateParallax();
        });

        function throttleUpdateParallax() {
            if (!isPaused && isScrolling) {
                if (!scrollAnimationFrame) {
                    scrollAnimationFrame = requestAnimationFrame(updateParallax);
                }
            }
        }


        function runLenis(timestamp) {
            if (!isPaused) {
                lenis.raf(timestamp);
                requestAnimationFrame(runLenis);
            }
        }

        if (!lenisInitialized) {
            lenisInitialized = true;
            requestAnimationFrame(runLenis);
        }

        function scrollToTop() {
            if (typeof window !== 'undefined') {
                window.scrollTo({
                    top: 0,
                    behavior: 'instant'
                });

                if (window.pageYOffset !== 0) {
                    setTimeout(() => {
                        window.scrollTo(0, 0);
                    }, 0);
                }
            }
        }

        // Save state and pause animations before navigation
        function saveStateAndPause(callback) {
            try {
                AnimationManager.pauseAnimations();
                savedState = AnimationManager.saveState(); // Save the state
                // Assume saveState is synchronous. If it is asynchronous, ensure to handle it accordingly.

                if (typeof callback === 'function') {
                    callback();
                }
            } catch (error) {
                console.error('Error in saveStateAndPause:', error);
                if (typeof callback === 'function') {
                    callback(); // Proceed to open the link even if there's an error
                }
            }
        }


        function restoreStateAndResume() {
            if (isIOS) {
                if (savedState) {
                    //console.log('Restoring state...');
                    AnimationManager.restoreState(savedState);
                    //console.log('State restored, resuming animations...');
                    AnimationManager.resumeAnimations();
                } else {
                    console.log('No saved state to restore.');
                }
            }
        }

        if (isIOS) {
            document.addEventListener('visibilitychange', () => {
                if (document.visibilityState === 'visible') {
                    //console.log("Visibility change detected, restoring state and resuming animations.");
                    restoreStateAndResume();
                }
            }, { once: true }); // Ensuring the listener is only installed once
        }





//////// IFRAME LOADING ////////
        


        var iframeIsVisible = false;
        let tiles = { a: false, b: false, viewerReady: false, iframeReady: false, menuReady: true };
        let observer; // Declare a global variable to store the observer instance
        let messageEventListenerAdded = false;
        let iframeObserverAdded = false;
        let sceneKey = null;

        function updateIframe(sceneKey) {
            const iframeContainer = document.getElementById('iframeContainer');
            const mouseOverlay = document.getElementById('mouseOverlay');
            const bodyGalleryContainer = document.getElementById('bodyGalleryContainer');
            let viewerContainers = [];

            // Enhanced cleanup function for existing iframe
            function cleanupIframe(iframe) {
                if (iframe) {
                    //console.log('Cleaning up existing iframe.');

                    // Lose WebGL context if possible
                    try {
                        const gl = iframe.contentWindow?.document.querySelector('canvas')?.getContext('webgl');
                        if (gl) {
                            const ext = gl.getExtension('WEBGL_lose_context');
                            if (ext) {
                                ext.loseContext();
                            }
                        }
                    } catch (e) {
                        // Suppress cross-origin errors
                        if (e instanceof DOMException && e.message.includes('Permission denied to access property')) {
                            // Silently handle specific cross-origin error
                        } else {
                            console.warn('Error losing WebGL context:', e);
                        }
                    }

                    // Disconnect the observer if it exists
                    try {
                        if (observer) {
                            observer.disconnect();
                            observer = null;
                        }
                    } catch (e) {
                        console.warn('Error disconnecting observer:', e);
                    }

                    // Attempt to safely remove event listeners and properties
                    try {
                        iframe.onload = null;
                        if (iframe.contentWindow) {
                            // Only try to access these properties if the iframe is same-origin
                            try {
                                if (iframe.contentWindow.location.origin === window.location.origin) {
                                    iframe.contentWindow.onunload = null;
                                    // Remove event listener if messageHandler is defined
                                    if (typeof messageHandler !== 'undefined') {
                                        iframe.contentWindow.removeEventListener('message', messageHandler);
                                    }
                                }
                            } catch (e) {
                                // Suppress cross-origin errors
                                if (e instanceof DOMException && e.message.includes('Permission denied to access property')) {
                                    // Silently handle specific cross-origin error
                                } else {
                                    console.warn('Error accessing iframe content properties:', e);
                                }
                            }
                        }
                    } catch (e) {
                        console.warn('Error cleaning up iframe:', e);
                    }

                    // Remove the iframe and set it to null
                    try {
                        iframe.src = 'about:blank';
                        iframe.remove();
                        iframe = null;
                        //console.log('Existing iframe cleaned up successfully.');
                    } catch (e) {
                        console.warn('Error removing iframe:', e);
                    }
                }
            }

            function cleanupViewerContainers() {
                viewerContainers.forEach(viewer => {
                    if (viewer.destroy) {
                        viewer.destroy();
                    }
                });
                viewerContainers = [];
            }

            // Remove existing iframe and clear body gallery content
            let existingIframe = document.getElementById('sceneIframe');
            if (existingIframe) {
                cleanupIframe(existingIframe);
            }
            if (bodyGalleryContainer) {
                resetLoadingStatus();
                bodyGalleryContainer.innerHTML = ''; // Clear body gallery content
            }

            cleanupViewerContainers(); // Clean up any existing viewer containers

            if (sceneKey === 'scene05') {
                hideFooterInstantly();
                lenis.start();
                if (typeof lenis !== 'undefined' && lenis !== null) {
                    lenis.scrollTo(0, { duration: 0.1 }); // Use Lenis to scroll to the top
                }
                // Logic for scene05 (Gallery)
                //console.log('Setting up scene05 (Gallery).');

                toggleRemoveFooterActivation();
                resetRemoveStyledFooterCounter();
                iframeContainer.style.display = 'none';
                if (mouseOverlay) {
                    mouseOverlay.style.display = 'none';
                }
                const bodyGallery = document.getElementById('bodyGalleryContainer');
                if (bodyGallery) {
                    bodyGallery.style.opacity = '1'; // Set opacity to fully visible
                } else {
                    console.error('bodyGalleryContainer not found in the DOM');
                }
                bodyGalleryContainer.style.display = 'block';

                loadGallery(); // Load the gallery for scene05
                unhideBackground();

            } else if (sceneKey === 'scene06') {
                // Logic for scene06 (Clipz)
                //console.log('Setting up scene06 (Clipz).');
                setupDirectIframe('CLIPZ.html'); // Load clipz2.html for scene06 directly into the body

            } else {
                // Logic for other scenes
                //console.log(`Setting up other scene: ${sceneKey}.`);
                setupIframe(`VIEWER.html?scene=${sceneKey}`);
            }

            function setupIframe(src) {
                //console.log('Setting up iframe.');
                iframeContainer.style.display = 'block';
                if (mouseOverlay) {
                    mouseOverlay.style.display = 'block';
                    mouseOverlay.style.zIndex = '1';
                }
                bodyGalleryContainer.style.display = 'none';

                let newIframe = document.createElement('iframe');
                newIframe.id = 'sceneIframe';
                newIframe.style.width = '100%';
                newIframe.style.height = '100vh';
                newIframe.style.border = 'none';
                newIframe.src = src;
                newIframe.setAttribute('aria-label', 'Scene Viewer');

                if (!messageEventListenerAdded) {
                    window.addEventListener('message', (event) => {
                        if (event.data === 'iframeLoaded') {
                            tiles.iframeReady = true;
                        }
                    });
                    messageEventListenerAdded = true; // Set the flag to true after adding the listener
                    
                }

                iframeContainer.appendChild(newIframe);
                hideBackground();
                scrollToTop();
                lenis.start();

                // Ensure the observer is set up after adding the iframe to the DOM
                iframeLoaded(newIframe);
            }

            function setupDirectIframe(src) {
                //console.log('Setting up direct iframe.');
                hideFooterInstantly();
                const newIframe = document.createElement('iframe');
                newIframe.id = 'sceneIframe';
                newIframe.style.width = '100%';
                newIframe.style.height = '100vh';
                newIframe.style.border = 'none';
                newIframe.style.display = 'none'; // Make iframe invisible on load
                newIframe.style.opacity = '0'; // Set initial opacity to 0
                newIframe.src = src;
                newIframe.setAttribute('aria-label', 'Scene Viewer');

                document.body.appendChild(newIframe); // Directly append to the body
                hideBackground();

                iframeLoaded(newIframe);

                unhideDirectIframe();
                stopGif();
                lenis.start();
                scrollToTop();
                setTimeout(() => {
                    lenis.stop();
                }, 111); // 1000 milliseconds = 1 second
            }

            function iframeLoaded(iframe) {
                //console.log('Iframe loaded, setting up observer.');
                // Wait for the iframe to load completely before setting up the observer
                iframe.onload = function () {
                    if (iframe.contentWindow) {
                        //console.log('Iframe contentWindow is available, setting up observer.');
                        setupObserver(iframe);
                    } else {
                        //console.error('Iframe contentWindow is not available after load!');
                    }
                };
            }

            function setupObserver(iframe) {
                if (iframeObserverAdded && observer) {
                    observer.disconnect();
                    iframeObserverAdded = false;
                }

                observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (iframe.contentWindow) {
                            iframe.contentWindow.postMessage({
                                type: 'visibilityChange',
                                isVisible: entry.isIntersecting
                            }, '*');

                            if (entry.isIntersecting) {
                                if (isGyroDevice) {
                                    window.enableGyro();
                                }
                            } else {
                                if (isGyroDevice) {
                                    window.disableGyro();
                                }
                            }
                        }
                    });
                }, {
                    root: null,
                    threshold: 0.1
                });
                observer.observe(iframe);
                iframeObserverAdded = true;
            }
        }



        function resetPageStyles() {
            //console.log('sweepsweep.');

            
               
            

          
            if (abortController) {
                    abortController.abort();
                }
            // Cancel animation frames through AnimationManager
            if (typeof AnimationManager !== 'undefined') {
                AnimationManager.cancelAnimations();
            }

            const galleryContainer = document.getElementById('gallery-container');
            if (galleryContainer) {
                // Remove event listeners and clear inner HTML
                const images = galleryContainer.querySelectorAll('img');
                images.forEach(img => {
                    img.onload = null;
                    img.onerror = null;
                    if (img.src.startsWith('blob:')) {
                        URL.revokeObjectURL(img.src); // Revoke the object URL
                    }
                });
                galleryContainer.innerHTML = ''; // Remove all children
            }


            // Clear dynamically created spans for text animations, excluding keep spans
            document.querySelectorAll('span:not(.keep)').forEach(span => span.remove());

            // Remove other dynamically created elements
            document.querySelectorAll('.hidden-char-XL').forEach(span => span.remove());
            document.querySelectorAll('.ascii-line-XL').forEach(div => div.remove());
            document.querySelectorAll('.flex-container.animation-container').forEach(div => div.remove());
            document.querySelectorAll('.flex-icontainer').forEach(div => div.remove());

            document.querySelectorAll('.scale-wrapper-background, .scale-wrapper-interface').forEach(wrapper => {
                wrapper.parentNode.removeChild(wrapper);
            });



            // Remove images not marked with 'keep' class
            document.querySelectorAll('img:not(.keep)').forEach(img => img.remove());

            // Clear GSAP global timeline
            if (typeof gsap !== 'undefined') {
                gsap.globalTimeline.clear();
            }

            // Clear intervals and timeouts, excluding the GIF timeout
            let id = window.setTimeout(function() {}, 0);
            while (id--) {
                if (id !== gifTimeoutId) {
                    window.clearTimeout(id);
                    window.clearInterval(id);
                }
            }

            // Three.js cleanup
            if (typeof renderer !== 'undefined') {
                renderer.dispose();
                renderer.forceContextLoss();
                renderer.context = null;
                renderer.domElement = null;
                renderer = null;
            }
            if (typeof scene !== 'undefined') {
                while (scene.children.length > 0) {
                    const child = scene.children[0];
                    scene.remove(child);
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(material => material.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                }
                scene = null; // Set scene to null to ensure it's garbage collected
            }
            if (typeof camera !== 'undefined') {
                camera = null;
            }

            // Clear observed elements and data
            observedElements = [];
            observedElementsData = [];

         
            // Reset tiles state
            tiles = { a: false, b: false, viewerReady: false, iframeReady: false, menuReady: true };

            // Reset message event listener flag
            messageEventListenerAdded = false;


        }











        function hideBackground() {
            setTimeout(() => {
                const background = document.querySelector('div[style*="background-color"]');
                if (background) {
                    background.remove(); // Remove the background element from the DOM
                }
                
                
            }, 111); // Delay of 500 milliseconds (adjust as needed)
        }



        function unhideBackground() {
            setTimeout(() => {
                const existingBackground = document.querySelector('div[style*="background-color"]');
                if (!existingBackground) {
                    const background = document.createElement('div');
                    background.style.position = 'absolute';
                    background.style.top = '0';
                    background.style.left = '0';
                    background.style.width = '100%';
                    background.style.height = '1vh';
                    background.style.zIndex = '-2';
                    background.style.backgroundColor = 'rgba(0, 0, 0, 0)'; // 10% grey
                    // Add more styles or content to the background as needed

                    document.body.insertBefore(background, document.body.firstChild);
                }
            }, 111); // Delay of 500 milliseconds
        }

 

        function unhideDirectIframe() {
            const iframe = document.getElementById('sceneIframe');
            if (iframe) {
                iframe.style.display = 'block'; // Make iframe visible

                setTimeout(() => {
                    if (isIOS) {
                        iframe.style.transition = 'none'; // Disable transition for iOS
                        iframe.style.opacity = '1'; // Set opacity to 1 immediately
                    } else {
                        iframe.style.transition = 'opacity 2s'; // Set transition for opacity
                        iframe.style.opacity = '1'; // Fade in by changing opacity to 1
                    }
                }, 100); // Delay to ensure the display change is rendered
            }
        }

        function hideDirectIframe() {
            const iframe = document.getElementById('sceneIframe');
            if (iframe) {
                if (isIOS) {
                    iframe.style.transition = 'none'; // Disable transition for iOS
                    iframe.style.opacity = '0'; // Set opacity to 0 immediately
                    setTimeout(() => {
                        iframe.style.display = 'none'; // Hide iframe after a short delay
                    }, 100); // Short delay to ensure the opacity change is rendered
                } else {
                    iframe.style.transition = 'opacity 1s'; // Set transition for opacity
                    iframe.style.opacity = '0'; // Fade out by changing opacity to 0
                    setTimeout(() => {
                        iframe.style.display = 'none'; // Hide iframe after transition
                    }, 1000); // Delay to ensure the transition completes
                }
            }
        }



        function hideFooterInstantly() {
            const footerContainer = document.getElementById('customStyledFooter');
            if (footerContainer) {
                footerContainer.style.display = 'none'; // Instantly hide the footer
            }
        }

        function unhideFooterInstantly() {
            const footerContainer = document.getElementById('customStyledFooter');
            if (footerContainer) {
                footerContainer.style.display = 'block'; // Instantly unhide the footer
            }
        }


//////// MOUSE HANDLING ///////////        

        let targetMouseX = window.innerWidth / 2, targetMouseY = window.innerHeight / 2;
        const maxSmoothingFactor = 0.111; // Maximum smoothing factor
        let isMouseInArea = false;
        let applySmoothing = false;

        const mouseOverlay = document.getElementById('mouseOverlay');

        // Consolidated Event Handler
        function handleMouseEvent(e, eventType) {
            e.preventDefault(); // Added preventDefault for better mobile experience

            if (eventType === 'enter') {
                isMouseInArea = true;
                applySmoothing = true; // Enable smoothing on entering
            } else if (eventType === 'leave') {
                isMouseInArea = false;
            }

            if (eventType !== 'leave') {
                targetMouseX = e.clientX - mouseOverlay.offsetLeft - mouseOverlay.offsetWidth / 2;
                targetMouseY = e.clientY - mouseOverlay.offsetTop - mouseOverlay.offsetHeight / 2;
            }
        }

        if (!mouseEventListenersAdded) {
            mouseOverlay.addEventListener('mouseenter', (e) => handleMouseEvent(e, 'enter'));
            mouseOverlay.addEventListener('mouseleave', (e) => handleMouseEvent(e, 'leave'));
            mouseOverlay.addEventListener('mousemove', (e) => handleMouseEvent(e, 'move'));
            mouseEventListenersAdded = true; // Set the flag to true after adding the listeners
        }

        // Animate Mouse Movement
        function animate() {
            if (!isIOS) {
                if (applySmoothing) {
                    const dx = targetMouseX - mouseX;
                    const dy = targetMouseY - mouseY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    const smoothingFactor = Math.min(distance / 100, maxSmoothingFactor);

                    mouseX += dx * smoothingFactor;
                    mouseY += dy * smoothingFactor;

                    // Disable smoothing when close enough
                    if (distance < 1) {
                        applySmoothing = false;
                        mouseX = targetMouseX;
                        mouseY = targetMouseY;
                    }
                } else {
                    mouseX = targetMouseX;
                    mouseY = targetMouseY;
                }

                sendMouseEventToIframe('mousemove', { clientX: mouseX, clientY: mouseY });
            } else {
                console.log('Animation is disabled on this device.');
            }
            return !isIOS;  // Return false if the animation should be excluded, to remove it from the animation list
        }

        // Register the animate function with the AnimationManager if not already registered
        if (!animateRegistered) {
            animateRegistered = true;
            AnimationManager.registerAnimation(animate);
        }

        // Update sendMouseEventToIframe to use coordinates
        function sendMouseEventToIframe(eventType, coordinates) {
            const iframe = document.getElementById('sceneIframe');
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage({
                    type: eventType,
                    mouseX: coordinates.clientX,
                    mouseY: coordinates.clientY
                }, '*');
            }
        }


//////// IMAGE LOADING ////////////////////

        let currentSceneData = null;

        async function fetchAndParseData() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/Mischlichter/data/main/assets/pages.txt');
                const text = await response.text();
                return parseText(text);
            } catch (error) {
                return null;
            }
        }

        


        function parseText(text) {
            //console.log("Original text:", text); // Print the original text

            // Split the text into scenes
            let scenes = text.split(/SCENE\d+:/);
            //console.log("Scenes after initial split:", scenes); // Print scenes after initial split

            // Remove the first empty element if it exists
            if (scenes[0].trim() === '') {
                scenes.shift();
            }

            let parsedData = [];

            scenes.forEach((scene, index) => {
                //console.log(`Processing scene ${index + 1}:`, scene); // Print the current scene being processed

                let sceneData = {
                    sceneKey: `scene${index + 1}`,
                    containers: {},
                    numberOfContainers: 0
                };

                // Split the scene into paragraphs and CSS
                let parts = scene.split(/#container\d+ \{/);
                //console.log(`Parts for scene ${index + 1}:`, parts); // Print the parts after splitting by container

                // First part is always paragraphs. Exclude the paragraph numbers.
                let paragraphs = parts[0].trim()
                    .split(/\n+\s*P\d+:?\s*/) // Split at paragraph markers, optional colon
                    .filter(p => p) // Remove empty strings from the array
                    .map((paragraph, index) => 
                        index === 0 ? paragraph.replace(/^P\d+:?\s*/, '').trim() : paragraph.trim()
                    );



                //console.log(`Paragraphs for scene ${index + 1}:`, paragraphs); // Print the paragraphs for the current scene

                // Calculate the number of containers
                sceneData.numberOfContainers = paragraphs.length;

                // Process CSS and associate with paragraphs
                for (let i = 1; i <= sceneData.numberOfContainers; i++) {
                    let css = parts[i] ? `#container${i.toString().padStart(2, '0')} {` + parts[i].split('}')[0].trim() + '}' : '';
                    let containerKey = `container${i.toString().padStart(2, '0')}`;
                    sceneData.containers[containerKey] = {
                        text: paragraphs[i - 1],
                        style: css
                    };
                    //console.log(`Container ${containerKey} for scene ${index + 1}:`, sceneData.containers[containerKey]); // Print each container's data
                }

                parsedData.push(sceneData);
            });

            //console.log("Parsed data:", parsedData); // Print the final parsed data
            return parsedData;
        }



        async function fetchImage() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/Mischlichter/data/main/assets/pagesi.txt');
                const text = await response.text();
                return parseImage(text);
            } catch (error) {
                return null;
            }
        }

        
        function parseImage(text) {
            //console.log("Starting image parsing...");

            // Split the text into scenes
            let scenes = text.split(/SCENE\d+:/);
            //console.log("Scenes identified:", scenes.length);

            // Remove the first empty element if it exists
            if (scenes[0].trim() === '') {
                scenes.shift();
                //console.log("Removed empty first element.");
            }

            let parsedImageData = [];

            scenes.forEach((scene, index) => {
                //console.log(`Processing scene ${index + 1}`);

                let sceneImageData = {
                    sceneKey: `scene${index + 1}`,
                    images: {}
                };

                // Extract image URLs and their CSS
                let imageMatches = scene.matchAll(/\n\nI\d+:\n(https?:\/\/\S+)/g);
                let cssMatches = scene.matchAll(/#i-container\d+ \{([\s\S]*?)\}/g);

                let cssStyles = {};
                for (const cssMatch of cssMatches) {
                    let cssKey = cssMatch[0].match(/#i-container(\d+)/)[1];
                    cssStyles[`i-container${cssKey.padStart(2, '0')}`] = cssMatch[1].trim();
                }

                for (const imageMatch of imageMatches) {
                    let imageNumber = imageMatch[0].match(/I(\d+)/)[1];
                    let imageKey = `i-container${imageNumber.padStart(2, '0')}`;
                    let imageCSS = cssStyles[imageKey] || '';

                    sceneImageData.images[imageKey] = {
                        src: imageMatch[1].trim(),
                        style: imageCSS
                    };
                    //console.log(`Found image: ${imageKey} -> ${imageMatch[1].trim()}, CSS: ${imageCSS}`);
                }

                parsedImageData.push(sceneImageData);
            });

            //console.log("Image parsing complete:", parsedImageData);
            return parsedImageData;
        }





//////// MENU LOADING //////////


        let isAnimating = false;

        function initializeMenu() {
            fetchAndParseMenuData().then(menuData => {
                if (menuData && menuData.length > 0) {
                    loadMenu(menuData);

                }
            });
        }



        async function fetchAndParseMenuData() {
            try {
                //console.log("Fetching menu data...");
                const response = await fetch('https://raw.githubusercontent.com/Mischlichter/data/main/assets/menu.txt');
                const text = await response.text();
                return parseMenuText(text);
            } catch (error) {
                //console.error("Error fetching menu data:", error);
                return [];
            }
        }

        function parseMenuText(text) {
            //console.log("Parsing menu text...");
            let menuItems = text.split('\n').filter(line => line.trim() !== '');
            return menuItems.map(item => {
                let [label, scene] = item.split(':');
                return { label, scene };
            });
        }

        let menuContainerIds = [];
        let isMenuLoaded = false;
        let blockMenuInteractions = false;  // This will control whether interactions are allowed
        var menufade = false;

        function blockInteractions() {
                blockMenuInteractions = true;
        }

        function unblockInteractions() {
            blockMenuInteractions = false;
        }

        function isInteractionBlocked() {
        return blockMenuInteractions;
        }

        async function getCachedImage(url) {
            try {
                // Open the specified cache
                const cache = await caches.open('site-assets');
                
                // Try to find a match for the URL in the cache
                const response = await cache.match(url);
                
                if (response) {
                    // If a match is found, convert the response to a Blob
                    const blob = await response.blob();
                    
                    // Create a local URL for the Blob object
                    const objectURL = URL.createObjectURL(blob);
                    
                    // Return the local URL for use in your application
                    return objectURL;
                } else {
                    console.log(`Cached file not found for URL: ${url}, downloading...`);
                }
            } catch (error) {
                console.error(`Error fetching cached image for URL ${url}:`, error);
            }
            
            // Fallback to the original URL if cache lookup fails
            console.log(`Falling back to original URL: ${url}`);
            return url;
        }

        async function loadMenu(menuData) {
            return new Promise((resolve, reject) => {
                isAnimating = true;

                setTimeout(() => {
                    isAnimating = false;
                }, 4000);

                let menuBar = document.querySelector('.menu-bar');
                if (!menuBar) {
                    menuBar = document.createElement('div');
                    menuBar.className = 'menu-bar';
                    document.body.appendChild(menuBar);
                } else {
                    menuBar.innerHTML = '';
                }

                // Small logo container
                const logoContainerSmall = document.createElement('div');
                logoContainerSmall.style.width = '63px';
                logoContainerSmall.style.height = '59px';
                logoContainerSmall.style.position = 'absolute';
                logoContainerSmall.style.left = '13.5%';
                logoContainerSmall.style.top = '50%';
                logoContainerSmall.style.transform = 'translate(-50%, -50%)';
                logoContainerSmall.style.overflow = 'hidden';
                logoContainerSmall.style.display = 'none'; // Initially hidden
                logoContainerSmall.classList.add('logo-small');
                menuBar.appendChild(logoContainerSmall);

                // Small animated GIF
           
                const gifSmall = document.createElement('img');
                gifSmall.style.width = '100%';
                gifSmall.style.height = '100%';
                gifSmall.style.position = 'absolute';
                gifSmall.style.top = '0';
                gifSmall.style.left = '0';
                gifSmall.style.display = 'none'; // Initially hidden
                gifSmall.id = 'menuGifSmall';
                gifSmall.classList.add('keep'); // Add the keep class
                logoContainerSmall.appendChild(gifSmall);
              

                // Small logo
                const logoImgSmall = document.createElement('img');
                logoImgSmall.style.width = '100%';
                logoImgSmall.style.height = '100%';
                logoImgSmall.style.position = 'relative';
                logoImgSmall.id = 'menuLogoSmall';
                logoImgSmall.alt = 'Menu Logo Small';
                logoImgSmall.classList.add('logo');
                logoContainerSmall.appendChild(logoImgSmall);

                // Large logo container
                const logoContainerLarge = document.createElement('div');
                logoContainerLarge.style.width = '154px';
                logoContainerLarge.style.height = '31px';
                logoContainerLarge.style.position = 'relative';
                logoContainerLarge.style.overflow = 'hidden';
                logoContainerLarge.style.display = 'none'; // Initially hidden
                menuBar.appendChild(logoContainerLarge);

                // Large animated GIF
              
                const gifLarge = document.createElement('img');
                gifLarge.style.width = '100%';
                gifLarge.style.height = '100%';
                gifLarge.style.position = 'absolute';
                gifLarge.style.top = '0';
                gifLarge.style.left = '0';
                gifLarge.style.display = 'none'; // Initially hidden
                gifLarge.id = 'menuGifLarge';
                gifLarge.classList.add('keep'); // Add the keep class
                logoContainerLarge.appendChild(gifLarge);
           

                // Large logo
                const logoImgLarge = document.createElement('img');
                logoImgLarge.style.width = '100%';
                logoImgLarge.style.height = '100%';
                logoImgLarge.style.position = 'relative';
                logoImgLarge.id = 'menuLogoLarge';
                logoImgLarge.alt = 'Menu Logo Large';
                logoImgLarge.classList.add('logo');
                logoContainerLarge.appendChild(logoImgLarge);

                fetchLogos().then(() => {
                    updateLogoVisibility();
                }).then(() => {
                    menuContainerIds = [];
                    let currentlyActiveMenuItemId = 'menuContainer0';

                    const handleInteraction = async (itemId, index) => {
                        if (blockMenuInteractions) return;
                        if ((currentlyActiveMenuItemId === 'menuLogo' && itemId === 'menuContainer0') ||
                            (currentlyActiveMenuItemId === 'menuContainer0' && itemId === 'menuLogo')) {
                            window.scrollTo({ top: 0, left: 0, behavior: 'smooth' });
                            return;
                        }

                        if (currentlyActiveMenuItemId === itemId) {
                            window.scrollTo({ top: 0, left: 0, behavior: 'smooth' });
                            return;
                        }

                        
                        isAnimating = false; // Reset the animation state
                        clearTimeout(gifTimeoutId); // Clear any existing timeout to stop the current GIF
                        startGif(); // Start the new GIF

                        currentlyActiveMenuItemId = itemId;
                        hideDirectIframe();
                        await fadeOutElements();
                        await resetPageStyles();

                        currentSceneIndex = (itemId === 'menuLogo') ? 0 : index;

                        // Load the selected scene
                        loadScene(currentSceneIndex);

                        // Always highlight the first menu item when the logo is clicked
                        if (itemId === 'menuLogo') {
                            highlightActiveMenuItem('menuContainer0'); // Highlight the first menu item when the logo is clicked
                        } else {
                            highlightActiveMenuItem(itemId); // Otherwise, highlight the current menu item
                        }
                    };

                    logoImgSmall.addEventListener('click', () => handleInteraction('menuLogo', 0));
                    logoImgSmall.addEventListener('touchend', () => handleInteraction('menuLogo', 0));
                    logoImgLarge.addEventListener('click', () => handleInteraction('menuLogo', 0));
                    logoImgLarge.addEventListener('touchend', () => handleInteraction('menuLogo', 0));

                    menuData.forEach((menuItem, index) => {
                        const menuContainer = document.createElement('div');
                        menuContainer.id = `menuContainer${index}`;
                        menuContainer.className = 'menu-container';
                        menuContainer.innerText = menuItem.label;
                        menuBar.appendChild(menuContainer);

                        let isTouch = false;

                        const handleMenuInteraction = async (event) => {
                            if (isTouch && event.type === 'click') return;
                            isTouch = event.type === 'touchend';
                            handleInteraction(menuContainer.id, index);
                        };

                        menuContainer.addEventListener('click', handleMenuInteraction);
                        menuContainer.addEventListener('click', () => animateTextDuringHover(menuContainer));

                        menuContainer.addEventListener('touchend', handleMenuInteraction);
                        menuContainer.addEventListener('touchend', () => animateTextDuringHover(menuContainer));

                        if (index === 0) {
                            setTimeout(() => {
                                animateTextDuringHover(menuContainer);
                                highlightActiveMenuItem(menuContainer.id); // Highlight the first menu item
                            }, 5000);
                        }

                        menuContainerIds.push(menuContainer.id);
                    });

                    const fakeMenuItem1 = document.createElement('div');
                    fakeMenuItem1.className = 'menu-container';
                    fakeMenuItem1.setAttribute('data-fake', 'true');
                    menuBar.insertBefore(fakeMenuItem1, menuBar.children[1]);

                    const fakeMenuItem2 = document.createElement('div');
                    fakeMenuItem2.className = 'menu-container';
                    fakeMenuItem2.setAttribute('data-fake', 'true');
                    menuBar.insertBefore(fakeMenuItem2, menuBar.children[6]);

                    resolve();
                }).then(() => {
                    updateMenu(menuData);
                    isMenuLoaded = true;
               

                }).catch(error => {
                    console.error('Error updating logo visibility:', error);
                    reject(error);
                });
            });
        }

        async function fetchLogos() {
            const smallLogoUrl = 'https://raw.githubusercontent.com/Mischlichter/data/main/interface/logoS.jpg';
            const largeLogoUrl = 'https://raw.githubusercontent.com/Mischlichter/data/main/interface/logo5.jpg';
            const smallGifUrl = 'https://raw.githubusercontent.com/Mischlichter/data/main/interface/logoSani.gif';
            const largeGifUrl = 'https://raw.githubusercontent.com/Mischlichter/data/main/interface/logo5ani.gif';

            const logoPromises = [
                getCachedImage(smallLogoUrl),
                getCachedImage(largeLogoUrl)
            ];

            
            logoPromises.push(getCachedImage(smallGifUrl), getCachedImage(largeGifUrl));
        

            const [smallLogo, largeLogo, smallGif, largeGif] = await Promise.all(logoPromises);

            const logoImgSmall = document.getElementById('menuLogoSmall');
            const logoImgLarge = document.getElementById('menuLogoLarge');
            
            const gifSmall = document.getElementById('menuGifSmall');
            const gifLarge = document.getElementById('menuGifLarge');
            gifSmall.src = smallGif;
            gifLarge.src = largeGif;
            

            logoImgSmall.src = smallLogo;
            logoImgLarge.src = largeLogo;
        }

        let currentLogoName = '';
        let currentMediaType = '';
        let callCount = 0;

        async function updateLogoVisibility() {
            const logoImgSmall = document.getElementById('menuLogoSmall');
            const logoImgLarge = document.getElementById('menuLogoLarge');
            const gifSmall = document.getElementById('menuGifSmall');
            const gifLarge = document.getElementById('menuGifLarge');
            const fakeMenuItems = document.querySelectorAll('.menu-container[data-fake="true"]');

            if (!logoImgSmall || !logoImgLarge || !gifSmall || !gifLarge) return;

            const logoContainerSmall = logoImgSmall.parentElement;
            const logoContainerLarge = logoImgLarge.parentElement;

            logoImgSmall.classList.add('keep');
            logoImgLarge.classList.add('keep');

            const width = window.innerWidth;
            const height = window.innerHeight;
            const isPortrait = width - 1 < height;

            let newLogoName = '';

            if (width <= 768 || isPortrait) {
                newLogoName = 'small';
            } else {
                newLogoName = 'large';
            }

            if (callCount > 0 && currentLogoName !== newLogoName) {
                currentLogoName = newLogoName;
                switchLogoAndGif(currentLogoName);
            }

            if (width <= 768 || isPortrait) {
                logoContainerSmall.style.display = 'block';
                logoContainerLarge.style.display = 'none';
                fakeMenuItems.forEach(item => item.style.display = '');
            } else {
                logoContainerSmall.style.display = 'none';
                logoContainerLarge.style.display = 'block';
                fakeMenuItems.forEach(item => item.style.display = 'none');
            }

            updateCssBasedOnOrientation(width, height, isPortrait);
            callCount++;
        }


        function switchLogoAndGif(newLogoName) {
            const logoImgSmall = document.getElementById('menuLogoSmall');
            const logoImgLarge = document.getElementById('menuLogoLarge');
            const gifSmall = document.getElementById('menuGifSmall');
            const gifLarge = document.getElementById('menuGifLarge');

            if (newLogoName === 'small') {
                updateMediaVisibility(logoImgSmall, gifSmall);
                logoImgLarge.style.display = 'none';
                gifLarge.style.display = 'none';
            } else {
                updateMediaVisibility(logoImgLarge, gifLarge);
                logoImgSmall.style.display = 'none';
                gifSmall.style.display = 'none';
            }
        }

        function updateMediaVisibility(logoElement, gifElement) {
            if (currentMediaType === 'gif') {
                gifElement.style.display = 'block';
                logoElement.style.display = 'none';
            } else {
                logoElement.style.display = 'block';
                gifElement.style.display = 'none';
            }
        }

        function updateCssBasedOnOrientation(width, height, isPortrait) {
            const menuBar = document.querySelector('.menu-bar');
            const menuContainers = document.querySelectorAll('.menu-container');

            if (width <= 768 || isPortrait) {
                menuBar.style.flexWrap = 'wrap';
                menuBar.style.padding = '5px';
                menuContainers.forEach(container => {
                    container.style.flex = '1 1 25%';
                    container.style.boxSizing = 'border-box';
                    container.style.textAlign = 'left';
                    container.style.padding = '5px';
                });
            } else {
                menuBar.style.flexWrap = 'nowrap';
                menuBar.style.padding = '10px 30px';
                menuContainers.forEach(container => {
                    container.style.flex = 'none';
                    container.style.boxSizing = 'content-box';
                    container.style.textAlign = 'center';
                    container.style.padding = '0';
                });
            }
        }

        let gifTimeoutId;
        let isStoppingGif = false;

        const framesPerLoop = 49; // Number of frames in one loop
        const frameRate = 30; // Frames per second
        const gifDuration = framesPerLoop / frameRate; // Duration of one loop in seconds

        function startGif() {
            

            const logoImgSmall = document.getElementById('menuLogoSmall');
            const logoImgLarge = document.getElementById('menuLogoLarge');
            const gifSmall = document.getElementById('menuGifSmall');
            const gifLarge = document.getElementById('menuGifLarge');

            const width = window.innerWidth;
            const height = window.innerHeight;
            const isPortrait = width - 1 < height;

            let gifElement, logoElement;

            if (width <= 768 || isPortrait) {
                logoElement = logoImgSmall;
                gifElement = gifSmall;
            } else {
                logoElement = logoImgLarge;
                gifElement = gifLarge;
            }

            if (logoElement && gifElement) {
                requestAnimationFrame(() => {
                    logoElement.style.display = 'none';
                    gifElement.style.display = 'block';

                    // Restart the GIF to ensure it starts from the first frame
                    const gifSrc = gifElement.src;
                    gifElement.src = '';
                    gifElement.src = gifSrc;

                    // Play the GIF in an endless loop
                    gifElement.loop = true;
                    isStoppingGif = false; // Reset stopping flag
                    currentMediaType = 'gif';
                });
            } else {
                console.error('Logo or GIF element not found');
            }
        }

        function stopGif() {
      

            const logoImgSmall = document.getElementById('menuLogoSmall');
            const logoImgLarge = document.getElementById('menuLogoLarge');
            const gifSmall = document.getElementById('menuGifSmall');
            const gifLarge = document.getElementById('menuGifLarge');

            const width = window.innerWidth;
            const height = window.innerHeight;
            const isPortrait = width - 1 < height;

            let gifElement, logoElement;

            if (width <= 768 || isPortrait) {
                logoElement = logoImgSmall;
                gifElement = gifSmall;
            } else {
                logoElement = logoImgLarge;
                gifElement = gifLarge;
            }

            if (logoElement && gifElement) {
                if (isStoppingGif) return; // Prevent multiple stop signals
                isStoppingGif = true;

                const currentTime = performance.now();
                const elapsedTime = (currentTime % (gifDuration * 1000)) / 1000; // Elapsed time in seconds
                const remainingTime = gifDuration - elapsedTime;

                // Wait until the end of the current loop
                setTimeout(() => {
                    // Disable infinite looping
                    gifElement.loop = false;

                    // Restart the GIF to ensure it starts from the first frame and add one additional loop
                    const gifSrc = gifElement.src;
                    gifElement.src = '';
                    gifElement.src = gifSrc;

                    // Wait for one additional loop duration
                    gifTimeoutId = setTimeout(() => {
                        gifElement.style.display = 'none';
                        logoElement.style.display = 'block';
                        isStoppingGif = false; // Reset stopping flag
                    }, gifDuration * 1000);
                }, remainingTime * 1000); // Convert remaining time to milliseconds
                currentMediaType = 'jpg';
            } else {
                console.error('Logo or GIF element not found');
            }
        }









//////// ANIMATION MENU ///////

        function updateMenu(menuData) {
            //console.log("Updating menu...");
            preparedMenuItems = {}; // Resetting for the new menu

            
            menuData.forEach((menuItem, index) => {
                let containerId = `menuContainer${index}`;
                let textLines = menuItem.label.split('\n'); // Changed from menuItem.title to menuItem.label
                //console.log("Preparing menu item:", menuItem.label);
                let lineSpans = createSpansForMenu(containerId, textLines.join(' '));
                preparedMenuItems[containerId] = lineSpans;
            });

            // Resetting the current animation index for menu
            currentContainerIndex = 0;
            containerIds = Object.keys(preparedMenuItems);



            startAllMenuAnimations();


        }


        function createSpansForMenu(containerId, text) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            //console.log("Creating spans for menu:", containerId);

            let tempSpan = document.createElement('span');
            tempSpan.style.display = 'inline-block';
            tempSpan.style.visibility = 'hidden';
            document.body.appendChild(tempSpan);

            let style = window.getComputedStyle(container);
            let paddingAndBorder = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) +
                                   parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
            let availableWidth = container.clientWidth - paddingAndBorder - 5;

            let lines = [];
            let currentLine = '';
            text.split(' ').forEach(word => {
                let testLine = currentLine + word + ' ';
                tempSpan.innerText = testLine;

                if (tempSpan.offsetWidth > availableWidth && currentLine !== '') {
                    let lineContainer = createLineContainerForMenu(container, currentLine.trim());
                    lines.push(lineContainer);
                    currentLine = word + ' ';
                } else {
                    currentLine = testLine;
                }
            });

            if (currentLine.trim() !== '') {
                let lineContainer = createLineContainerForMenu(container, currentLine.trim());
                lines.push(lineContainer);
            }

            document.body.removeChild(tempSpan);
            return lines;
        }

        function createLineContainerForMenu(container, lineText) {
            let lineContainer = document.createElement('div');
            lineContainer.classList.add('keep'); // Add class to line container
            lineContainer.style.display = 'inline-block';
            lineContainer.style.width = '100%';
            container.appendChild(lineContainer);

            //console.log("Creating line container for:", lineText);

            lineText.split(' ').forEach(word => {
                if (word.trim() !== '') {
                    var wordSpan = document.createElement('span');
                    wordSpan.className = 'dynamic-text keep'; // Add keep class
                    wordSpan.setAttribute('data-final-text', word);
                    wordSpan.style.opacity = '0';
                    lineContainer.appendChild(wordSpan);
                }
            });

            return lineContainer;
        }



        function startAnimationForMenuContainer(containerId) {
            ///console.log("Starting animation for container:", containerId);
            if (preparedMenuItems[containerId]) {
                startLineAnimation(preparedMenuItems[containerId]);
            } else {
                //console.log("No prepared data for container:", containerId);
            }
        }


        function startAllMenuAnimations() {
            if (!isMenuLoaded) {
                //console.log("Menu is not loaded yet. Retrying...");
                setTimeout(startAllMenuAnimations, 100); // Retry after 500 milliseconds
                return;
            }

            menuContainerIds.forEach(containerId => {
                startAnimationForMenuContainer(containerId);
                if (containerId === 'menuContainer0') {
                    initializeFirstScene();
                }
            });
        }

        function initializeFirstScene() {
            document.querySelectorAll('.ascii-line-XL').forEach(div => div.remove());
            currentSceneIndex = 0; // Set to the first scene
            //loadScene(currentSceneIndex); // Load the first scene
            fadeInmenu();

            
            
        }



        function shuffleMenu() {
            let menuItems = document.querySelectorAll('.menu-container');
            
            menuItems.forEach(menuItem => {
                if (!menuItem.dataset.originalText) {
                    menuItem.dataset.originalText = menuItem.textContent;
                }
                //console.log("Original text:", menuItem.dataset.originalText); // Log original text
                animateMenuDuringScaling(menuItem, menuItem.dataset.originalText);
            });
        }


        function animateMenuDuringScaling(element, finalText) {
            var totalDuration = 300; // Total duration of the scrambling
            var randomStartDelay = Math.random() * 200; // Start scrambling with random delay
            var stopScramblingDelay = totalDuration - 200 + Math.random() * 400; // When to stop scrambling
            var startTime = null;
            var animationRegistered = false;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                var progress = timestamp - startTime;

                if (progress < stopScramblingDelay) {
                    var scrambledText = generateRandomString(finalText.length);
                    element.textContent = scrambledText;
                    //console.log("Scrambled text:", scrambledText); // Log scrambled text
                    return true; // Continue the animation
                } else {
                    element.textContent = finalText;
                    element.style.opacity = '1';
                    //console.log("Final text set to:", element.textContent); // Log final text
                    if (progress >= totalDuration) {
                        element.removeAttribute('data-originalText'); // Clean up
                        return false; // Stop the animation
                    }
                }
            }

            setTimeout(function() {
                AnimationManager.registerAnimation(step);
            }, randomStartDelay);
        }


        function animateTextDuringHover(element, finalDuration = 150) {
            // Check if an animation is in progress
            if (isAnimating) {
                //console.log("Animation already in progress. Hover animation blocked.");
                return; // Exit the function if an animation is already happening
            }

            // Capture the original text only if it has not been stored yet
            if (!element.dataset.originalText) {
                element.dataset.originalText = element.textContent;
            }

            const originalText = element.dataset.originalText; // Use the stored original text
            let startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                const progress = timestamp - startTime;

                if (progress < finalDuration) {
                    // Scramble text
                    const scrambledText = generateRandomString(originalText.length);
                    element.textContent = scrambledText;
                    return true; // Continue the animation
                } else {
                    // Revert back to the original text
                    element.textContent = originalText;
                    return false; // Stop the animation
                }
            }

            // Register the animation with the AnimationManager
            AnimationManager.registerAnimation(step);
        }
        // Attach the event listener to each menu item for hover animation
        document.querySelectorAll('.menu-container').forEach(item => {
            item.addEventListener('mouseover', () => animateTextDuringHover(item));
        });




        function highlightActiveMenuItem(activeMenuItemId) {
            // Remove active class from all menu items
            document.querySelectorAll('.menu-container').forEach(item => {
                item.classList.remove('active-menu-item');
            });

            // Add active class to the current menu item
            const activeItem = document.getElementById(activeMenuItemId);
            if (activeItem) {
                activeItem.classList.add('active-menu-item');
            }
        }

//////// SZENE LOADER /////////////////////////////////////////////////////////////////////////


        let currentSceneIndex = 0;
        let scenesData = [];
        let scenesiData = [];

        async function initialize() {
            
            scenesData = await fetchAndParseData();
            scenesiData = await fetchImage();

            
            if ((scenesData && scenesData.length > 0) && (scenesiData && scenesiData.length > 0)) {
                loadScene(currentSceneIndex);
            }
        }



        // Keep track of dynamically added style elements
        const dynamicStyles = [];

  
        async function loadScene(index) {
            const scene = scenesData[index];
            const sceneImages = scenesiData[index]; // Assuming scenesiData is structured similarly

            let formattedSceneKey = scene.sceneKey.length === 6 ? `scene0${scene.sceneKey.charAt(5)}` : scene.sceneKey;
            lenis.stop();

            // Update the iframe with the new scene
            updateIframe(formattedSceneKey);

            if (!scene) return;

            // Remove all existing containers and dynamic styles
            const existingContainers = document.querySelectorAll('.flex-container, .flex-icontainer');
            existingContainers.forEach(container => container.remove());
            
            // Clear dynamic styles
            dynamicStyles.forEach(style => style.remove());
            dynamicStyles.length = 0; // Clear the array
            handleScroll();
            loadInterface(index);

            // Merge and sort text and image containers
            let combinedData = [];
            Object.keys(scene.containers).forEach(key => {
                combinedData.push({ type: 'text', key: key, content: scene.containers[key] });
            });

            if (sceneImages && sceneImages.images) {
                Object.keys(sceneImages.images).forEach(key => {
                    combinedData.push({ type: 'image', key: key, content: sceneImages.images[key] });
                });
            }

            combinedData.sort((a, b) => {
                let numA = parseInt(a.key.match(/\d+/)[0], 10);
                let numB = parseInt(b.key.match(/\d+/)[0], 10);
                return numA - numB || (a.type === 'text' ? -1 : 1);
            });

            // Function to get the image from the cache
            async function getCachedImage(url) {
                try {
                    const cache = await caches.open('site-assets');
                    const response = await cache.match(url);
                    if (response) {
                        const blob = await response.blob();
                        const objectURL = URL.createObjectURL(blob);
                        return objectURL;
                    } else {
                        console.log(`Cached file not found for URL: ${url}, downloading...`);
                    }
                } catch (error) {
                    console.error(`Error fetching cached image for URL ${url}:`, error);
                }
                return url;
            }

            triggerOrientationWithoutCalibration();

            // Create containers in sorted order
            combinedData.forEach(async (item) => {
                const container = document.createElement('div');
                container.id = item.key;
                container.className = item.type === 'text' ? 'flex-container' : 'flex-icontainer';
                
                                
                
                document.body.appendChild(container);

                if (item.type === 'text') {
                    attachLinkToContainer(container, item.content.style);
                }

                if (container.className === 'flex-icontainer') {
                    container.style.opacity = '0.01';
                }


                const style = document.createElement('style');
                style.innerHTML = item.content.style;
                document.head.appendChild(style);
                dynamicStyles.push(style);



                if (item.type === 'image') {
                    const image = document.createElement('img');
                    const cachedImage = await getCachedImage(item.content.src);
                    image.src = cachedImage;
                    image.alt = 'Scene Image'; // Add this line
                    container.appendChild(image);
                }

            });

            // Create and style the footer
            createStyledFooter();

            currentSceneData = scene;

            // Update containers when loading a new scene
            updateAllContainers(scene);
            installObserver();
            observeElementsForAnimations();
            createScrollToTopButton();
            highlightActiveMenuItem(`menuContainer${index}`);
        }


        function extractLinkFromCSS(css) {
            const linkPattern = /\/\* link: (.*) \*\//; // Pattern to extract URL from comment
            const match = css.match(linkPattern);
            if (match) {
                //console.log("Extracted link:", match[1].trim());
                return match[1].trim();
            } else {
                //console.log("No link found in CSS.");
                return null;
            }
        }

       
        function attachLinkToContainer(container, css) {
            const link = extractLinkFromCSS(css);
            if (link) {
                container.style.cursor = 'pointer'; // Changes the cursor to pointer to indicate it's clickable
                container.addEventListener('click', (event) => {
                    if (isIOS) {
                        event.preventDefault(); // Prevent the default action to ensure saveStateAndPause completes first
                        saveStateAndPause(() => {
                            window.open(link, '_blank', 'noopener noreferrer'); // Open link in new tab with security attributes
                        });
                    } else {
                        window.open(link, '_blank', 'noopener noreferrer'); // Open link in new tab with security attributes
                    }
                });
            }
        }





        let scrollToTopButton = null;
        let scrollTimeout = null;

        function createScrollToTopButton() {
            if (scrollToTopButton) {
                // If the button already exists, do not create a new one
                return;
            }

            scrollToTopButton = document.createElement('button');
            scrollToTopButton.id = 'scrollToTopButton';
            scrollToTopButton.innerHTML = '<span class="keep" style="position: relative; top: -5px;">▲</span>'; // Triangle symbol adjusted
            scrollToTopButton.style.cssText = `
                position: fixed; 
                bottom: 30px; 
                right: 30px; 
                width: 48px;  /* Increased width for a wider appearance */
                height: 48px; /* Same as width to maintain circular shape */
                line-height: 50px; /* Center the triangle vertically */
                text-align: center; /* Center the triangle horizontally */
                padding: 0;
                font-size: 24px; /* Larger font size for the triangle */
                background-color: transparent; /* Background made transparent */
                box-shadow: 4px 4px 8px rgba(0, 0, 0, 0.2);
                color: #00ffcc;
                border: 2px solid #00ffcc;
                border-radius: 50%;
                cursor: pointer;
                z-index: 17;
                display: none;
                opacity: 0;
                transition: opacity 0.5s ease; /* Smooth transition for opacity */
            `;
            document.body.appendChild(scrollToTopButton);

            // Function to scroll to the top smoothly
            function scrollToTopS() {
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });

                const iframe = document.getElementById('sceneIframe');
                if (iframe) {
                    const src = iframe.src;
                    iframe.src = 'about:blank';
                    iframe.src = src;
                }
            }

            // Listen to both click and touchend events
            scrollToTopButton.addEventListener('click', scrollToTopS);
            scrollToTopButton.addEventListener('touchend', function(event) {
                event.preventDefault(); // Prevent the mouse event from firing
                scrollToTopS();
            });

            // Show and hide button with fade effects when scrolling
            
        }

        function handleScroll() {
            if (!scrollToTopButton) return;

            clearTimeout(scrollTimeout);

            // Hide button during scrolling
            scrollToTopButton.style.opacity = 0;

            // Set a timeout to check if scrolling has stopped
            scrollTimeout = setTimeout(() => {
                if (window.scrollY > 1111) {
                    scrollToTopButton.style.display = 'block';
                    requestAnimationFrame(() => {
                        scrollToTopButton.style.opacity = 1;
                    });
                } else {
                    scrollToTopButton.style.display = 'none';
                }
            }, 500); // Reduced debounce duration for quicker response
        }

        



        function preventScrollBeyondFooter() {
            const footerContainer = document.getElementById('customStyledFooter');
            if (!footerContainer) return;

            const maxScrollY = document.body.offsetHeight - window.innerHeight - footerContainer.offsetHeight + 111;

            if (window.scrollY > maxScrollY) {
                if (!isIOS) {
                    lenis.stop();
                }

                window.scrollTo({
                    top: maxScrollY,
                    behavior: 'smooth'
                });

                if (!isIOS) {
                    setTimeout(() => {
                        lenis.start();
                    }, 500);
                }
            }
        }

        function combinedScrollHandler() {
            preventScrollBeyondFooter();

            debounce(() => {
                if (currentSceneIndex === 4) {
                    saveScrollPosition();
                }
            }, 200)();

            handleScroll();
        }

        function addScrollListener() {
            if (!isScrollListenerAdded) {
                window.addEventListener('scroll', combinedScrollHandler);
                isScrollListenerAdded = true;
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function() {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, arguments), wait);
            };
        }

        function createStyledFooter() {
            removeStyledFooter();
            const footerContainer = document.createElement('div');
            footerContainer.id = 'customStyledFooter';
            footerContainer.style.width = '100vw';
            footerContainer.style.height = '5000px';
            footerContainer.style.backgroundColor = 'black';
            footerContainer.style.color = 'white';
            footerContainer.style.display = 'flex';
            footerContainer.style.flexDirection = 'column';
            footerContainer.style.alignItems = 'center';
            footerContainer.style.justifyContent = 'center';
            footerContainer.style.position = 'relative';
            footerContainer.style.zIndex = '16';
            footerContainer.style.marginTop = '256px';
            footerContainer.style.boxShadow = '0px -50px 30px -20px rgba(0, 0, 0, 0.5)';

            const styleBlock = document.createElement('style');
            styleBlock.innerHTML = `
                .icon-size {
                    font-size: 18px;
                }
                @media (max-width: 768px) {
                    .icon-size {
                        font-size: 20px;
                    }
                    .btn-floating {
                        padding: 10px;
                    }
                }
            `;
            document.head.appendChild(styleBlock);

            footerContainer.innerHTML = `
                <div style="display: flex; align-items: flex-start; justify-content: center; flex-wrap: wrap; margin-top: -4900px;">
                    <a class="btn btn-outline-light btn-floating m-1" href="https://twitter.com/Funkybrown111" role="button" style="color: white; margin: 0 10px;" target="_blank" rel="noopener noreferrer" aria-label="Twitter">
                        <i class="fa-brands fa-twitter icon-size" aria-hidden="true"></i>
                    </a>
                    <a class="btn btn-outline-light btn-floating m-1" href="https://www.instagram.com/hogeal_bot/" role="button" style="color: white; margin: 0 10px;" target="_blank" rel="noopener noreferrer" aria-label="Instagram">
                        <i class="fa-brands fa-instagram icon-size" aria-hidden="true"></i>
                    </a>
                    <a class="btn btn-outline-light btn-floating m-1" href="mailto:hogeai@web.de" role="button" style="color: white; margin: 0 15px;" target="_blank" rel="noopener noreferrer" aria-label="Email">
                        <i class="fa-solid fa-envelope icon-size" aria-hidden="true"></i>
                    </a>
                    <a class="btn btn-outline-light btn-floating m-1" href="https://t.me/officialhogecommunity" role="button" style="color: white; margin: 0 10px;" target="_blank" rel="noopener noreferrer" aria-label="Telegram">
                        <i class="fa-brands fa-telegram icon-size" aria-hidden="true"></i>
                    </a>
                    <a class="btn btn-outline-light btn-floating m-1" href="https://www.hoge.gg/" role="button" style="color: white; margin: 0 10px;" target="_blank" rel="noopener noreferrer" aria-label="Hoge">
                        <i class="fa-solid fa-bone icon-size" aria-hidden="true"></i>
                    </a>
                </div>
                <div style="margin-top: 5px;">
                    © 2024 Copyright: <a class="text-white" href="https://HogeAI.com/" style="color: white;">HogeAI.com</a>
                </div>
            `;
            document.body.appendChild(footerContainer);

            preventScrollBeyondFooter();
            //addScrollListener();
        }




        // Flag to control the activation of footer removal
        let isRemoveFooterActive = false;

        // Function to toggle the removal activation
        function toggleRemoveFooterActivation() {
            isRemoveFooterActive = !isRemoveFooterActive;
            //console.log(`RemoveStyledFooter is now ${isRemoveFooterActive ? 'active' : 'inactive'}.`);
        }

        // Modified removeStyledFooter function
        let removeStyledFooterCounter = 0; // Initialize a counter for the function calls

        function removeStyledFooter() {
            // Check if the action is active
            if (!isRemoveFooterActive) {
                //console.log('RemoveStyledFooter is inactive. Exiting function.');
                return; // Exit the function if not active
            }
            
            const footerContainer = document.getElementById('customStyledFooter');
            if (footerContainer) {
                document.body.removeChild(footerContainer);
                //console.log('Styled footer removed.');
                removeStyledFooterCounter++; // Increment the counter after a successful removal
                
                // Check if the function has run 2 times
                if (removeStyledFooterCounter >= 2) {
                    isRemoveFooterActive = false; // Deactivate the function
                    //console.log('RemoveStyledFooter has been set to inactive after running 2 times.');
                }
                
            } else {
                //console.log('No styled footer found to remove.');
            }
        }


        function resetRemoveStyledFooterCounter() {
            removeStyledFooterCounter = 0;
            //console.log('The counter for removeStyledFooter has been reset.');
        }




//////// Interface Loadin //////
      

        
        function fadeInElements() {
            const waitForTiles = () => {
                return new Promise((resolve) => {
                    const checkTiles = () => {
                        if (tiles.a && tiles.b && tiles.viewerReady && tiles.iframeReady && tiles.menuReady) {
                            resolve(); // Resolve the promise when all conditions are met
                        } else {
                            setTimeout(checkTiles, 100); // Check every 100 milliseconds
                        }
                    };
                    checkTiles(); // Start checking tiles
                });
            };

            const waitForImages = () => {
                return new Promise((resolve) => {
                    const images = document.querySelectorAll('img');
                    let loadedCount = 0;
                    const totalImages = images.length;

                    images.forEach((img) => {
                        if (img.complete) {
                            loadedCount++;
                        } else {
                            img.addEventListener('load', () => {
                                loadedCount++;
                                if (loadedCount === totalImages) {
                                    resolve();
                                }
                            });
                            img.addEventListener('error', () => {
                                loadedCount++;
                                if (loadedCount === totalImages) {
                                    resolve();
                                }
                            });
                        }
                    });

                    if (loadedCount === totalImages) {
                        resolve();
                    }
                });
            };

            Promise.all([waitForTiles(), waitForImages()]).then(() => {
                const selectors = ['#interfaceContainer', '#backgroundContainer', '#iframeContainer', '#bodyGalleryContainer', '.flex-container'];
                let animationCount = 0;
                let shouldFadeIn = false;

                const animationEndHandler = () => {
                    animationCount--;
                    if (animationCount === 0) {
                        shouldFadeIn = true; // Set the flag after all animations have ended
                    }
                };

                selectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(element => {
                        if (element) {
                            animationCount++;
                            element.style.opacity = 1; // Set opacity to 1
                            if (isIOS) {
                                element.style.transition = 'none'; // Remove transitions for iOS
                                initializeScrollHandling();
                                stopGif();
                              
                                //lenis.start();
                                //disableScroll()
                            } else {
                                element.style.transition = 'opacity 1s ease-in-out'; // Apply transitions for non-iOS
                                initializeScrollHandling();
                                stopGif();

                                //lenis.start();
                                //disableScroll()
                            }
                            element.addEventListener('transitionend', animationEndHandler);
                        }
                    });
                });

                if (animationCount === 0) {
                    shouldFadeIn = true; // If no animations, immediately set the flag
                }
            });
        }

        function fadeInmenu() {
            updateLogoVisibility();
            return new Promise((resolve) => {
                const selectors = ['.menu-bar', '.menu-container'];
                let animationCount = 0;
                let menufade = false;

                const animationEndHandler = () => {
                    animationCount--;
                    if (animationCount === 0) {
                        // Set the flag after all animations have ended
                        menufade = true;
                        tiles.menuReady = true; // Set menuReady to true when animations have completed
                        resolve(); // Resolve the promise to indicate that animations have completed
                    }
                };

                selectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(element => {
                        if (element) {
                            animationCount++;
                            element.style.opacity = 1; // Set opacity to 1
                            if (!isIOS) {
                                element.style.transition = 'opacity 0.5s ease-in-out'; // Apply a half-second transition for non-iOS
                                element.addEventListener('transitionend', animationEndHandler);
                                startGif();
                            } else {
                                // If it's iOS, immediately set the flag and resolve the promise
                                menufade = true;
                                tiles.menuReady = true; // Set menuReady to true for iOS
                                resolve();
                                startGif();
                            }
                        }
                    });
                });

                // If no animations are found, resolve the promise immediately
                if (animationCount === 0) {
                    tiles.menuReady = true; // Set menuReady to true if no animations are found
                    resolve();
                }
            });
        }



        function fadeOutElements() {
            return new Promise((resolve, reject) => {
                const selectors = ['#interfaceContainer', '#backgroundContainer', '.flex-icontainer', '#bodyGalleryContainer', '.flex-container', '#iframeContainer'];
                const elementsToFadeOut = [];
                selectors.forEach(selector => {
                    const elements = document.querySelectorAll(selector);
                    elements.forEach(element => {
                        if (element) {
                            elementsToFadeOut.push(element);
                        }
                    });
                });

                elementsToFadeOut.forEach(element => {
                    element.style.opacity = 0; // Set opacity to 0
                    if (isIOS) {
                        element.style.transition = 'none'; // Remove transitions for iOS
                        
                    } else {
                        element.style.transition = 'opacity 1s ease-in-out'; // Apply transitions for non-iOS

                    }
                });

                // Assuming the transition duration is 1 second as set in CSS for non-iOS devices
                setTimeout(resolve, isIOS ? 0 : 1000); // Resolve immediately for iOS
            });
        }








        function createVerticalTiles_a(containerId, imageUrl, imageHeight) {
            return new Promise((resolve) => {
                const container = document.getElementById(containerId);
                container.innerHTML = '';

                const containerDiv = document.createElement('div');
                containerDiv.style.width = '100%';
                containerDiv.style.height = `${imageHeight * 23}px`; // Adjust height based on number of tiles
                containerDiv.style.backgroundImage = `url(${imageUrl})`;
                containerDiv.style.backgroundRepeat = 'repeat-y';
                containerDiv.style.backgroundSize = 'contain'; // Adjust this to fit your needs

                container.appendChild(containerDiv);

                delayedVirtualCanvasUpdate();

                resolve();
            }).then(() => {
                tiles.a = true;
            });
        }

        function createVerticalTiles_b(containerId, imageUrl, imageHeight) {
            return new Promise((resolve) => {
                const container = document.getElementById(containerId);
                container.innerHTML = '';

                const containerDiv = document.createElement('div');
                containerDiv.style.width = '100%';
                containerDiv.style.height = `${imageHeight * 23}px`; // Adjust height based on number of tiles
                containerDiv.style.backgroundImage = `url(${imageUrl})`;
                containerDiv.style.backgroundRepeat = 'repeat-y';
                containerDiv.style.backgroundSize = 'contain'; // Adjust this to fit your needs

                container.appendChild(containerDiv);
                shouldUpdateAllContainers = false;
                updateVirtualCanvasSize();

                resolve();
            }).then(() => {
                tiles.b = true;
            });
        }

        function delayedVirtualCanvasUpdate() {
            // Delay the call to updateVirtualCanvasSize
            shouldUpdateAllContainers = false;
            setTimeout(updateVirtualCanvasSize, 100); // Delay of 100 milliseconds
        }



        async function initializeCacheStatus(urls) {
            const cacheName = 'site-assets';
            const cache = await caches.open(cacheName);

            const cachePromises = urls.map(async (url) => {
                const response = await cache.match(url);
                const cacheKey = `cache_${url}`;
                if (response) {
                    localStorage.setItem(cacheKey, 'cached');
                } else {
                    localStorage.setItem(cacheKey, 'not_cached');
                }
            });

            await Promise.all(cachePromises);
        }


        // This function should be called with all the URLs you plan to use
        function initializeCacheForDynamicUrls(sceneIndices) {
            const baseUrls = [
                'https://raw.githubusercontent.com/Mischlichter/data/main/interface/background/b',
                'https://raw.githubusercontent.com/Mischlichter/data/main/interface/side/s',
                'https://raw.githubusercontent.com/Mischlichter/data/main/interface/viewer/v',
                'https://raw.githubusercontent.com/Mischlichter/data/main/interface/viewer/vm'
            ];

            const urls = [];
            for (const baseUrl of baseUrls) {
                for (const index of sceneIndices) {
                    const formattedIndex = index.toString().padStart(2, '0');
                    urls.push(`${baseUrl}${formattedIndex}.jpg`);
                    if (baseUrl.includes('vm')) {
                        urls.push(`${baseUrl}${formattedIndex}.png`);
                    }
                }
            }

            initializeCacheStatus(urls);
        }

        // Call this function at the beginning with all possible scene indices
        initializeCacheForDynamicUrls([0, 1, 2, 3]);


        async function getCachedOrFetchImage(url) {
            const cacheName = 'site-assets';
            const cache = await caches.open(cacheName);
            let cachedResponse = await cache.match(url);

            if (cachedResponse) {
                //console.log(`Serving from cache: ${url}`);
                return URL.createObjectURL(await cachedResponse.blob()); // Create a local URL for the cached response
            } else {
                //console.log(`Fetching from network: ${url}`);
                try {
                    const response = await fetch(url);
                    if (response.ok) {
                        await cache.put(url, response.clone());
                        return url;
                    } else {
                        console.error(`Failed to fetch image at ${url}`);
                        return url;
                    }
                } catch (error) {
                    console.error(`Error fetching image for URL ${url}:`, error);
                    return url;
                }
            }
        }



        async function loadInterface(currentSceneIndex) {
            function ensureWrapperExistence(wrapperClass, contentStructure) {
                let wrapper = document.querySelector(`.${wrapperClass}`);
                if (!wrapper) {
                    wrapper = document.createElement('div');
                    wrapper.className = wrapperClass;
                    document.body.appendChild(wrapper);
                    wrapper.innerHTML = contentStructure;
                }
            }

            if (currentSceneIndex === 4 || currentSceneIndex === 5) {
                document.querySelectorAll('.scale-wrapper-background, .scale-wrapper-interface').forEach(wrapper => {
                    wrapper.parentNode.removeChild(wrapper);
                });
                return;
            }
            shouldUpdateAllContainers = false;
            updateVirtualCanvasSize();

            ensureWrapperExistence('scale-wrapper-background', `
                <div id="backgroundRoot">
                    <div id="backgroundContainer">
                        <div id="backgroundInterfaceContainer">
                            <div id="interfaceBackground"></div>
                        </div>
                    </div>
                </div>
            `);

            ensureWrapperExistence('scale-wrapper-interface', `
                <div id="interfaceContainer">
                    <div id="interfaceSideLeft" class="sideImageContainer"></div>
                    <div id="interfaceViewerContainer">
                        <img id="interfaceViewerImage" alt="Viewer Image">
                    </div>
                    <div id="interfaceSideRight" class="sideImageContainer"></div>
                </div>
            `);

            const sceneFormatted = currentSceneIndex.toString().padStart(2, '0');
            const imageHeight = 2048;

            const backgroundUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/background/b${sceneFormatted}.jpg`;
            const sideImageUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/side/s${sceneFormatted}.jpg`;
            const viewerImageUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/viewer/v${sceneFormatted}.jpg`;
            const viewerMaskUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/viewer/vm${sceneFormatted}.png`;

            try {
                const backgroundImage = await getCachedOrFetchImage(backgroundUrl);
                const sideImage = await getCachedOrFetchImage(sideImageUrl);
                const viewerImage = await getCachedOrFetchImage(viewerImageUrl);
                const viewerMaskImage = await getCachedOrFetchImage(viewerMaskUrl);

                const backgroundPromise = createVerticalTiles_a('interfaceBackground', backgroundImage, imageHeight);
                const sideLeftPromise = createVerticalTiles_b('interfaceSideLeft', sideImage, imageHeight);
                const sideRightPromise = createVerticalTiles_b('interfaceSideRight', sideImage, imageHeight);

                const viewerImagePromise = new Promise((resolve, reject) => {
                    const viewerImageElement = document.getElementById('interfaceViewerImage');
                    if (viewerImageElement && document.body.contains(viewerImageElement)) {
                        const tempImage = new Image();
                        tempImage.onload = function () {
                            viewerImageElement.src = tempImage.src;
                            viewerImageElement.style.maskImage = `url('${viewerMaskImage}')`;
                            viewerImageElement.style.webkitMaskImage = `url('${viewerMaskImage}')`;
                            viewerImageElement.style.maskSize = '100% 100%';
                            viewerImageElement.style.webkitMaskSize = '100% 100%';
                            tiles.viewerReady = true; // Move this inside onload to ensure it's ready
                            resolve();
                        };
                        tempImage.onerror = function () {
                            console.error("Failed to load image at url:", viewerImageUrl);
                            reject();
                        };
                        tempImage.src = viewerImage;

                    } else {
                        console.log("Viewer image element does not exist in the DOM.");
                        reject();
                    }
                });

                await Promise.all([backgroundPromise, sideLeftPromise, sideRightPromise, viewerImagePromise]);
                fadeInElements();
            } catch (error) {
                console.error("Error loading elements:", error);
            }
        }



   
   
     
     
    
     
        let frameCount = 0;
        let lastUpdateTimeout = null;
 
     

        const transitionDuration = 320; // Duration of the smooth transition in milliseconds
        let wasScaling = false; // Flag to detect transition from scaling to not scaling

        function updateParallax() {
            if (isIOS) return;

            if (isscaling) {
                wasScaling = true;
                frameCount++;
                if (frameCount % 320 !== 0) {
                    // Schedule the final update if no consecutive updates follow
                    clearTimeout(lastUpdateTimeout);
                    lastUpdateTimeout = setTimeout(() => {
                        if (isscaling) {
                            executeParallaxUpdate(true);
                        }
                    }, 320); // Adjust the delay as needed for optimal performance
                    return;
                }
            } else {
                if (wasScaling) {
                    // Trigger smooth transition for the final update
                    wasScaling = false;
                    executeParallaxUpdate(true);
                } else {
                    frameCount = 0; // Reset frame count when not scaling
                    executeParallaxUpdate(false);
                }
            }
        }

        function executeParallaxUpdate(applySmoothTransition) {
            const speedFactorBackground = 0.3;
            const speedFactorSides = -1.2;
            const speedFactorViewer = -0.3;
            const scrollY = window.scrollY;

            if (scrollY === lastScrollY) {
                isScrolling = false;
                cancelAnimationFrame(scrollAnimationFrame);
                scrollAnimationFrame = null;
                return;
            }

            lastScrollY = scrollY;

            const background = document.getElementById('interfaceBackground');
            const sideLeft = document.getElementById('interfaceSideLeft');
            const sideRight = document.getElementById('interfaceSideRight');
            const viewerContainer = document.getElementById('interfaceViewerContainer');

            if (applySmoothTransition) {
                addSmoothTransition();
                
            } else {
                removeSmoothTransition();
                
            }

            requestAnimationFrame(() => {
                if (background) {
                    const offsetBackground = scrollY * speedFactorBackground;
                    background.style.transform = `translateY(${offsetBackground}px)`;
                }

                if (sideLeft && sideRight) {
                    const offsetSides = scrollY * speedFactorSides;
                    sideLeft.style.transform = `translateY(${offsetSides}px)`;
                    sideRight.style.transform = `translateY(${offsetSides}px)`;
                }

                if (viewerContainer) {
                    const offsetViewer = scrollY * speedFactorViewer;
                    viewerContainer.style.transform = `translateY(${offsetViewer}px)`;
                }

                isScrolling = false;
                scrollAnimationFrame = null;

                // If we applied a smooth transition, remove it after the transition duration
                if (applySmoothTransition) {
                    setTimeout(removeSmoothTransition, transitionDuration);
                }
            });
        }

        function addSmoothTransition() {
            const elements = document.querySelectorAll('#interfaceBackground, #interfaceSideLeft, #interfaceSideRight, #interfaceViewerContainer');
            elements.forEach(element => {
                if (!element.classList.contains('smooth-transition')) {
                    element.classList.add('smooth-transition');
                }
            });
        }

        function removeSmoothTransition() {
            const elements = document.querySelectorAll('#interfaceBackground, #interfaceSideLeft, #interfaceSideRight, #interfaceViewerContainer');
            elements.forEach(element => {
                if (element.classList.contains('smooth-transition')) {
                    element.classList.remove('smooth-transition');
                }
            });
        }


           
     







/////////// ANIMATION TEXT /////

    

        function generateRandomString(length) {
            const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*()[]{}|';
            let randomString = '';
            for (let i = 0; i < length; i++) {
                randomString += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return randomString;
        }

        function animateText(element, finalText, duration, delay, finalColor = { r: 0, g: 255, b: 204 }) {
            setTimeout(() => {
                let currentText = generateRandomString(finalText.length);
                element.textContent = currentText;
                element.style.opacity = '0';

                const shuffleFrequency = 8;
                const intervalTime = duration / (finalText.length * shuffleFrequency);
                let index = 0;
                let shuffleCount = 0;
                let lastRender = performance.now();
                let frameCount = 0;
                const totalFrames = 180;
                const randomPhaseR = Math.random() * 2 * Math.PI;
                const randomPhaseG = Math.random() * 2 * Math.PI;
                const randomPhaseB = Math.random() * 2 * Math.PI;

                function getColorComponent(phaseShift, randomPhase) {
                    return Math.floor(127.5 * (1 + Math.sin(2 * Math.PI * frameCount / totalFrames + phaseShift + randomPhase)));
                }

                function step(timestamp) {
                    let progress = timestamp - lastRender;
                    if (progress > intervalTime) {
                        lastRender = timestamp - (progress % intervalTime);

                        if (shuffleCount % shuffleFrequency === 0 && index < finalText.length) {
                            currentText = currentText.substring(0, index) + finalText.charAt(index) + generateRandomString(finalText.length - index - 1);
                            index++;
                        } else {
                            currentText = currentText.substring(0, index) + generateRandomString(finalText.length - index);
                        }
                        element.textContent = currentText;
                        shuffleCount++;
                        element.style.opacity = Math.min(1, parseFloat(element.style.opacity) + 0.05);

                        let colorTransitionFactor = index / finalText.length;
                        let r = getColorComponent(0, randomPhaseR);
                        let g = getColorComponent(2 * Math.PI / 3, randomPhaseG);
                        let b = getColorComponent(4 * Math.PI / 3, randomPhaseB);

                        r = Math.floor(r + (finalColor.r - r) * colorTransitionFactor);
                        g = Math.floor(g + (finalColor.g - g) * colorTransitionFactor);
                        b = Math.floor(b + (finalColor.b - b) * colorTransitionFactor);

                        element.style.color = `rgb(${r}, ${g}, ${b})`;
                        frameCount++;

                        if (index === finalText.length && shuffleCount % shuffleFrequency === 0) {
                            element.textContent = finalText;
                            element.style.opacity = '1';
                            element.style.color = `rgb(${finalColor.r}, ${finalColor.g}, ${finalColor.b})`;
                            return false; // Indicate the animation is complete
                        }
                    }
                    return true; // Indicate the animation should continue
                }

                AnimationManager.registerAnimation(step);
            }, delay);
        }

        function createSpansForContainer(containerId, text) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            // Create a temporary span for measurements only once
            let tempSpan = document.createElement('span');
            tempSpan.style.display = 'inline-block';
            tempSpan.style.visibility = 'hidden';
            document.body.appendChild(tempSpan);

            let style = window.getComputedStyle(container);
            let paddingAndBorder = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) +
                                   parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
            let availableWidth = container.clientWidth - paddingAndBorder - 5;

            // Calculate 10% additional width
            let extendedWidth = availableWidth * 1.095;

            let lines = [];
            let currentLine = '';
            const words = text.split(' ');

            // Only one DOM manipulation to add spans
            let fragment = document.createDocumentFragment();

            words.forEach(word => {
                let testLine = currentLine + word + ' ';
                tempSpan.innerText = testLine;

                if (tempSpan.offsetWidth > extendedWidth && currentLine !== '') {
                    let lineContainer = createLineContainer(fragment, currentLine.trim());
                    lines.push(lineContainer);
                    currentLine = word + ' ';
                } else {
                    currentLine = testLine;
                }
            });

            if (currentLine.trim() !== '') {
                let lineContainer = createLineContainer(fragment, currentLine.trim());
                lines.push(lineContainer);
            }

            container.appendChild(fragment);
            document.body.removeChild(tempSpan);

            return lines;
        }

        function createLineContainer(container, lineText) {
            
            let lineContainer = document.createElement('div');
            lineContainer.style.display = 'inline-block';
            lineContainer.style.width = '1000%'; // Maintain original width setting
            container.appendChild(lineContainer);
            lineContainer.style.whiteSpace = 'nowrap';
            lineText.split(' ').forEach(word => {
                if (word.trim() !== '') {
                    var wordSpan = document.createElement('span');
                    wordSpan.className = 'dynamic-text';
                    wordSpan.setAttribute('data-final-text', word);
                    wordSpan.style.opacity = '0';
                    lineContainer.appendChild(wordSpan);
                }
            });

            return lineContainer;
        }

        function startLineAnimation(lineContainers, defaultFinalColor = { r: 0, g: 255, b: 204 }) {
            let wordDelayIncrement = 100;
            let lineStartDelay = 150;

            // Pre-populate line containers with blank spaces or invisible characters
            lineContainers.forEach(lineContainer => {
                Array.from(lineContainer.children).forEach(wordSpan => {
                    wordSpan.textContent = '\u00A0'; // Non-breaking space
                });
            });

            // Start the animation by replacing the placeholders with actual text
            lineContainers.forEach((lineContainer, lineIndex) => {
                Array.from(lineContainer.children).forEach((wordSpan, wordIndex) => {
                    let totalDelay = (lineIndex * lineStartDelay) + (wordIndex * wordDelayIncrement);
                    let colorData = wordSpan.getAttribute('data-color');
                    let finalColor = colorData ? JSON.parse(colorData) : defaultFinalColor; // Use default if no specific color is provided

                    setTimeout(() => {
                        animateText(wordSpan, wordSpan.getAttribute('data-final-text'), 1000, totalDelay, finalColor);
                    }, totalDelay);
                });
            });
        }



        

////////ANIMATION SCALING
        let preparedContainers = {};

        function updateAllContainers(Scene) {
            // Remove old spans before creating new ones
            clearTextAnimationElements();
            adjustContainerSizesBasedOnVirtualCanvas();
            preparedContainers = {}; // Resetting for the new Scene
            Object.keys(Scene.containers).forEach(containerId => {
                let containerData = Scene.containers[containerId];
                let textLines = containerData.text.split('\n');
                let lineSpans = createSpansForContainer(containerId, textLines.join(' '));
                preparedContainers[containerId] = lineSpans;
            });

            // Resetting the current animation index
            currentContainerIndex = 0;
            containerIds = Object.keys(Scene.containers);
        }

  

        function startAnimationForContainer(containerId) {
            if (preparedContainers[containerId]) {
                startLineAnimation(preparedContainers[containerId], { r: 0, g: 255, b: 204 });
            }
        }


        let isscaling = false;
        let resizeCallCount = 0;
        const resizeThreshold = 25; // Execute on every twenty-fifth call
        let resizeTimeout;
        const resizeTimeoutDuration = 500; // 0.5 seconds
        let lastClosestElementData = null;
        const scrollTopThreshold = 100; // Distance from the top of the page within which the scroll adjustment is skipped

   

        function updateAllContainersDuringScaling() {
            if (!currentSceneData) {
                return; // Exit if not set
            }
            isscaling = true;
            lenis.stop();


            // Save the initial height of the document
            const initialHeight = document.body.scrollHeight;

            // Save the viewport positions of observed elements
            saveElementsViewportPosition();
            clearTextAnimationElements();

        
            Object.keys(currentSceneData.containers).forEach(containerId => {
                let containerData = currentSceneData.containers[containerId];
                let textLines = containerData.text.split('\n');
                let lineSpans = createSpansForContainer(containerId, textLines.join(' '));
                let containerElement = document.getElementById(containerId);

                // Check if the container is in the viewport before starting the scaling animation
                if (isElementInViewport(containerElement)) {
                    //console.log(`Animating container: ${containerId}`);
                    startScalingAnimation(lineSpans);
                } else {
                    //console.log(`Updating container text directly: ${containerId}`);
                    // Update the text directly without animation
                    setFinalTextDirectly(lineSpans);
                    containerElement.innerHTML = '';
                    lineSpans.forEach(span => containerElement.appendChild(span));
                }
            });

            // Calculate the new height and adjust the scroll position immediately
            resizeCallCount++;
            //console.log(`resizeCallCount: ${resizeCallCount}`);
            if (resizeCallCount === 1 || resizeCallCount % resizeThreshold === 0) {
                // console.log("Executing getClosestElementToViewportCenter logic.");
                lastClosestElementData = getClosestElementToViewportCenter();
            }
            

            if (lastClosestElementData) {
                const newHeight = document.body.scrollHeight;
                const heightDifference = newHeight - initialHeight;
                if (window.scrollY > scrollTopThreshold) {
                // Adjust the scroll position by the height difference
                    window.scrollTo(0, window.scrollY + heightDifference);


                    const { element, viewportCenter } = lastClosestElementData;
                    const currentViewportCenter = (element.getBoundingClientRect().top + element.getBoundingClientRect().bottom) / 2;
                    const adjustment = currentViewportCenter - viewportCenter;

                    window.scrollTo(0, window.scrollY + adjustment);
                    
              

                    
                } else {
                    //console.log("Skipping scroll adjustment because the current scroll position is close to the top of the page.");
                }
            }

            // Reset the counter after the timeout duration
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                //console.log("Resetting resizeCallCount.");
                resizeCallCount = 0;
                lastClosestElementData = null;
                isscaling = false;
                lenis.start();
            }, resizeTimeoutDuration);



            
        }





        // Helper function to check if an element is in the viewport
        function isElementInViewport(el, margin = 300) {
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            const extendedTop = -margin;
            const extendedBottom = (window.innerHeight || document.documentElement.clientHeight) + margin;
            const extendedLeft = -margin;
            const extendedRight = (window.innerWidth || document.documentElement.clientWidth) + margin;
            return (
                rect.top >= extendedTop &&
                rect.left >= extendedLeft &&
                rect.bottom <= extendedBottom &&
                rect.right <= extendedRight
            );
        }


        // Function to directly set the final text
        function setFinalTextDirectly(lineContainers) {
            lineContainers.forEach(lineContainer => {
                Array.from(lineContainer.children).forEach(wordSpan => {
                    wordSpan.textContent = wordSpan.getAttribute('data-final-text');
                    wordSpan.style.opacity = '1';

                });
            });
        }




        function animateTextDuringScaling(element, finalText) {
            var currentText = generateRandomString(finalText.length);
            element.textContent = currentText;
            element.style.opacity = '1';

            var totalDuration = 300;  // Total duration of the scrambling
            var randomStartDelay = Math.random() * 200;  // Start scrambling with random delay
            var stopScramblingDelay = totalDuration - 200 + Math.random() * 400;  // Stop scrambling with random delay
            var startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                var progress = timestamp - startTime;

                if (progress < stopScramblingDelay) {
                    currentText = generateRandomString(finalText.length);
                    element.textContent = currentText;
                    return true; // Indicate that the animation should continue
                } else {
                    element.textContent = finalText;
                    return false; // Indicate that the animation is complete
                }
            }

            setTimeout(function() {
                AnimationManager.registerAnimation(step);
            }, randomStartDelay);
        }





        function startScalingAnimation(lineContainers) {
            lineContainers.forEach(lineContainer => {
                Array.from(lineContainer.children).forEach(wordSpan => {
                    animateTextDuringScaling(wordSpan, wordSpan.getAttribute('data-final-text'));
                });
            });
        }


        function clearTextAnimationElements() {
            const textAnimationElements = document.querySelectorAll('.dynamic-text');
            textAnimationElements.forEach(element => {
                if (!element.closest('.menu-container')) { // Exclude elements within the menu
                    element.remove();
                }
            });
        }

        
    

 


        function getSmoothAspectRatio(viewportWidth, viewportHeight) {
            const portraitAspectRatio = 1.6;
            const landscapeAspectRatio = 1.9;
            const transitionAspectRatio = 4 / 3;
            const currentAspectRatio = viewportWidth / viewportHeight;

            if (currentAspectRatio < 1) {
                return portraitAspectRatio;
            } else if (currentAspectRatio < transitionAspectRatio) {
                const t = (currentAspectRatio - 1) / (transitionAspectRatio - 1);
                return portraitAspectRatio + t * (landscapeAspectRatio - portraitAspectRatio);
            } else {
                return landscapeAspectRatio;
            }
        }



        let lastUpdate2 = 0;
        let targetFPS2 = 25; // Adjust this value to change the update rate for updateVirtualCanvasSize
        let interval2 = 1000 / targetFPS2;

        

        var lastScaleFactor = null; // Tracks the last scale factor for portrait mode
        var cumulativeScaleChange = 0; // Accumulates scale changes for portrait mode

        function updateVirtualCanvasSize() {
            const now = performance.now();
            if (now - lastUpdate2 < interval2) {
                return;
            }
            lastUpdate2 = now;

            var virtualcanvas = document.getElementById('virtualcanvas');
            if (!virtualcanvas) {
                virtualcanvas = document.createElement('div');
                virtualcanvas.id = 'virtualcanvas';
                document.body.appendChild(virtualcanvas);
                virtualcanvas.style.transition = 'transform 0.5s ease';
                virtualcanvas.style.position = 'absolute';
                virtualcanvas.style.left = '50%';
                virtualcanvas.style.transform = 'translate(-50%, -50%)';
                virtualcanvas.style.zIndex = '-100';
            }

            var viewportWidth = window.innerWidth;
            var viewportHeight = window.innerHeight;
            var isPortrait = viewportWidth - 1 < viewportHeight;
            var smoothAspectRatio = getSmoothAspectRatio(viewportWidth, viewportHeight);
            var fixedAspectRatio = 1536 / 1024;

            var canvasWidth, canvasHeight;
            var offset = 20; // Offset to adjust the starting point of the grid step calculation
            if (isPortrait) {
                var newHeight = viewportHeight / smoothAspectRatio;
                var stepSize = 80; // Define the step size
                var baseHeight = newHeight + offset; // Add the offset before adjusting to step
                var adjustedHeight = Math.round(baseHeight / stepSize) * stepSize; // Adjust to the nearest step
                canvasHeight = adjustedHeight - offset; // Subtract the offset after adjustment to maintain original canvas size
                canvasWidth = canvasHeight * fixedAspectRatio;
            } else {
                canvasWidth = viewportWidth;
                canvasHeight = canvasWidth / smoothAspectRatio;
            }

            var size = { width: canvasWidth, height: canvasHeight };
            var scaleFactor = Math.min(size.width / 1536, size.height / 1024);

            // Apply the scale factor for all modes without checking for changes
            document.querySelectorAll('.scale-wrapper-interface').forEach(element => {
                var verticalOffset = isIOS ? '45px' : '-50%'; // Adjusting Y-offset for iOS devices
                element.style.transform = `translate(-50%, ${verticalOffset}) scale(${scaleFactor})`;
            });

            // For .scale-wrapper-background and others, keep the original transformation
            document.querySelectorAll('.scale-wrapper-background').forEach(element => {
                element.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
            });

            // Update the virtual canvas size
            virtualcanvas.style.width = size.width + 'px';
            virtualcanvas.style.height = size.height + 'px';
            virtualcanvas.style.top = '50%';

            adjustContainerSizesBasedOnVirtualCanvas();
        }

        function setTargetFPS2(newFPS) {
            targetFPS2 = newFPS;
            interval2 = 1000 / targetFPS2;
        }


        let lastUpdate3 = 0;
        let targetFPS3 = 4; // Adjust this value to change the update rate for adjustContainerSizesBasedOnVirtualCanvas
        let interval3 = 1000 / targetFPS3;
        let initialCallCount = 0; // Counter to track the number of initial calls
        let initialCallLimit = 2; // Number of initial calls to allow without throttling

        // Throttling for adjustContainerSizesBasedOnVirtualCanvas
        function adjustContainerSizesBasedOnVirtualCanvas() {
            const now = performance.now();
            if (initialCallCount < initialCallLimit) {
                initialCallCount++;
            } else if (now - lastUpdate3 < interval3) {
                return;
            }
            lastUpdate3 = now;

            // Set a timeout to reset the initial call counter after one second
            setTimeout(() => {
                initialCallCount = 0;
            }, 1000);

            const virtualCanvas = document.getElementById('virtualcanvas');
            if (!virtualCanvas) return;

            const virtualCanvasWidth = virtualCanvas.offsetWidth;
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const isMobile = viewportWidth <= 768;
            const isPortrait = viewportHeight > viewportWidth;

            const adjustmentFactor = (isMobile || isPortrait) ? (isPortrait ? 1.3 : 1) : 1;

            const baseWidthPercent = getSmoothBaseWidthPercent(viewportWidth, viewportHeight);
            const scaledWidthPx = (virtualCanvasWidth * baseWidthPercent / 100) * adjustmentFactor;

            const container01 = document.getElementById('container01');
            if (container01) {
                container01.style.marginTop = isPortrait ? '30%' : '25%';
            }

            document.querySelectorAll('.flex-container, .flex-icontainer').forEach(container => {
                container.style.width = `${scaledWidthPx}px`;
                if (container.classList.contains('flex-icontainer')) {
                    container.style.paddingTop = `${scaledWidthPx}px`;
                }
            });

            if (shouldUpdateAllContainers) {
                updateAllContainersDuringScaling();
            }
        }

        function getSmoothBaseWidthPercent(viewportWidth, viewportHeight) {
            const startWidthPercent = 48;
            const endWidthPercent = 39;
            const transitionAspectRatio = 4 / 3;
            const currentAspectRatio = (viewportWidth - 1) / viewportHeight;

            if (currentAspectRatio < 1) {
                return endWidthPercent;
            } else if (currentAspectRatio >= 1 && currentAspectRatio < transitionAspectRatio) {
                const t = (currentAspectRatio - 1) / (transitionAspectRatio - 1);
                return startWidthPercent + t * (endWidthPercent - startWidthPercent);
            } else {
                return endWidthPercent;
            }
        }

        function setTargetFPS3(newFPS) {
            targetFPS3 = newFPS;
            interval3 = 1000 / targetFPS3;
        }




      
    
        

        function handleResize(sceneIndex) {
            // Always call these functions on resize
            shouldUpdateAllContainers = true;
            updateVirtualCanvasSize();
            
            updateLogoVisibility();
            


            // Exclude the following code from running on iOS devices
            if (isIOS) {
                scrollElementToViewportCenter();
                return; // Exit the function if on an iOS device
            }

            if (isAnimating) {
                return; // Exit the function if an animation is already happening
            }

            // Call these functions if not on an iOS device
            shuffleMenu();
            

            // If in the gallery scene, call handleGalleryResize
            
        }

        function scrollElementToViewportCenter() {
            const closestElementData = getClosestElementToViewportCenter();

            if (closestElementData && closestElementData.element instanceof HTMLElement) {
                const element = closestElementData.element;
                const elementRect = element.getBoundingClientRect();
                const elementCenter = elementRect.top + (elementRect.height / 2);
                const viewportCenter = window.innerHeight / 2;
                const scrollOffset = elementCenter - viewportCenter;

                setTimeout(() => {
                    window.scrollTo({
                        top: window.scrollY + scrollOffset,
                        behavior: 'smooth'
                    });
                }, 500); // 0.5 second delay
            } else {
                console.error("getClosestElementToViewportCenter did not return valid element data.");
            }
        }




        function handleGalleryResize() {
            // Determine the orientation and set variableori
            let variableori;
            if (window.innerWidth > window.innerHeight) {
                // Landscape orientation
                variableori = 75;
            } else {
                // Portrait orientation
                variableori = 98;
            }

            if (savedElement) {
                const newRect = savedElement.getBoundingClientRect();
                const newTop = newRect.top + window.scrollY - variableori;
                const newSavedPosition = savedPosition + (newTop - savedPosition);

                window.scrollTo({
                    top: newSavedPosition,
                    behavior: 'instant'
                });
                //console.log(`Scrolled to new position: ${newSavedPosition}`);

                ignoreSaveScroll = true;
                setTimeout(() => {
                    ignoreSaveScroll = false;
                }, 3000);
            }
        }
 
 
        let observedElements = [];
        let observedElementsData = [];
        let containerIds = []; // Assume you will populate this with relevant IDs

        function observeElementsForAnimations() {
            const observerOptions = {
                threshold: [0.01, 0.25],
                rootMargin: '50px'
            };

            const observerCallback = (entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        if (entry.target.classList.contains('animation-container')) {
                            if (entry.intersectionRatio >= 0.05 && !entry.target.dataset.animationStarted) {
                                startAnimationForContainer(entry.target.id);
                                entry.target.dataset.animationStarted = 'true';
                                observer.unobserve(entry.target);
                            }
                        }
                    }
                });
            };

            const observer = new IntersectionObserver(observerCallback, observerOptions);

            // Unobserve previous elements
            observedElements.forEach(element => observer.unobserve(element));
            observedElements = [];

            const elementsToObserve = containerIds.map(id => document.getElementById(id)).filter(Boolean);

            elementsToObserve.forEach(element => {
                if (element && !element.dataset.observed) {
                    if (!element.classList.contains('animation-container')) {
                        element.classList.add('animation-container');
                    }
                    observer.observe(element);
                    element.dataset.observed = 'true';
                    observedElements.push(element);
                }
            });
        }

        function saveElementsViewportPosition() {
            observedElementsData = observedElements.map(element => ({
                element,
                viewportCenter: (element.getBoundingClientRect().top + element.getBoundingClientRect().bottom) / 2
            }));
        }

        function getClosestElementToViewportCenter() {
            const viewportCenter = window.innerHeight / 2;
            let closestElementData = null;
            let minDistanceToCenter = Infinity;

            const allElementsData = observedElementsData.concat(
                observedFlexContainers.map(element => {
                    const rect = element.getBoundingClientRect();
                    const elementCenter = (rect.top + rect.bottom) / 2;
                    return {
                        element: element,
                        viewportCenter: elementCenter
                    };
                })
            );

            allElementsData.forEach(data => {
                const distanceToCenter = Math.abs(data.viewportCenter - viewportCenter);
                if (distanceToCenter < minDistanceToCenter) {
                    closestElementData = data;
                    minDistanceToCenter = distanceToCenter;
                }
            });

            return closestElementData;
        }

        let observedFlexContainers = [];

        function installObserver() {
            const observerOptions = {
                threshold: 0.25,
                rootMargin: '50px'
            };

            const observerCallback = (entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting && entry.intersectionRatio >= 0.25 && entry.target.style.opacity !== '1') {
                        entry.target.style.transition = 'opacity 0.7s ease-in-out'; // Add CSS transition for smooth fade-in
                        entry.target.style.opacity = '1'; // Fade in
                        // observer.unobserve(entry.target); // Stop observing after fade-in if needed
                    }
                });
            };

            const observer = new IntersectionObserver(observerCallback, observerOptions);

            // Unobserve previous elements
            observedFlexContainers.forEach(element => observer.unobserve(element));
            observedFlexContainers = [];

            const elementsToObserve = document.querySelectorAll('.flex-icontainer');

            elementsToObserve.forEach(element => {
                if (element && !element.dataset.observed) {
                    // Ensure the initial opacity remains 50% if already set
                    if (element.style.opacity === '' || element.style.opacity === '0') {
                        element.style.opacity = '0.01';
                    }
                    observer.observe(element);
                    element.dataset.observed = 'true';
                    observedFlexContainers.push(element);
                }
            });
        }

      

        
        
        let isWheelListenerAdded = false;

        if (!isWheelListenerAdded) {
            document.addEventListener('wheel', preventScrollZoom, { passive: false });
            isWheelListenerAdded = true;
        }

        function preventScrollZoom(event) {
            if (event.ctrlKey) {
                event.preventDefault();
            }
        }






        let isResizeListenerAdded = false;

        if (!isResizeListenerAdded) {
            let lastHeight = window.innerHeight;
            const heightChangeThreshold = 96;

            // Recalculate on window resize
            window.addEventListener('resize', function() {
                const currentHeight = window.innerHeight;

                if (isIOS) {
                    const heightDifference = Math.abs(currentHeight - lastHeight);
                    if (heightDifference > heightChangeThreshold) {
                        if (currentSceneIndex === 4) {
                            handleGalleryResize();
                        } else {
                            handleResize();
                        }
                        lastHeight = currentHeight;
                    }
                } else {
                    if (currentSceneIndex === 4) {
                        handleGalleryResize();
                        updateLogoVisibility();
                        shuffleMenu();
                    } else {
                        handleResize();
                    }
                }
            });
            isResizeListenerAdded = true;
        }







        


        



        let savedElement = null;
        let savedPosition = 0;
        let ignoreSaveScroll = false;

        function saveScrollPosition() {
          if (ignoreSaveScroll) return;

          const galleryContainer = document.getElementById('gallery-container');
          if (currentSceneIndex === 4 && galleryContainer) {
            //console.log("Saving scroll position...");

            const imageContainers = Array.from(galleryContainer.getElementsByClassName('image-container'));
            const viewportTop = window.scrollY;
            let closestImageContainer = null;
            let closestDistance = Infinity;

            for (let imageContainer of imageContainers) {
              const rect = imageContainer.getBoundingClientRect();
              const distance = Math.abs(rect.top);
              if (distance < closestDistance) {
                closestDistance = distance;
                closestImageContainer = imageContainer;
              }
            }

            if (closestImageContainer) {
              savedElement = closestImageContainer;
              savedPosition = closestImageContainer.getBoundingClientRect().top + viewportTop;
              //console.log(`Saved position: ${savedPosition}`);
            }
          }
        }

        


        let isScrollListenerAdded = false;

        function combinedScrollHandler() {
            preventScrollBeyondFooter();

            // Debounced saveScrollPosition only for scene index 4
            debounce(() => {
                if (currentSceneIndex === 4) {
                    saveScrollPosition();
                }
            }, 200)();

            handleScroll();
        }

        function addScrollListener() {
            if (!isScrollListenerAdded) {
                window.addEventListener('scroll', combinedScrollHandler);
                isScrollListenerAdded = true;
            }
        }

        function debounce(func, wait) {
            let timeout;
            return function() {
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(this, arguments), wait);
            };
        }



        // Call this function when all the elements are constructed
        function initializeScrollHandling() {
            // Ensure any construction logic here
            addScrollListener();
        }


        let isScrollDisabled = false;

        function preventDefault(e) {
            e.preventDefault();
        }

        function disableScroll() {
            if (!isScrollDisabled) {
                // Add event listeners to prevent scrolling
                window.addEventListener('wheel', preventDefault, { passive: false });
                window.addEventListener('touchmove', preventDefault, { passive: false });
                isScrollDisabled = true;
            }
        }

        function enableScroll() {
            if (isScrollDisabled) {
                // Remove event listeners to re-enable scrolling
                window.removeEventListener('wheel', preventDefault);
                window.removeEventListener('touchmove', preventDefault);
                isScrollDisabled = false;
            }
        }


        

        


        //initialize();
    </script>
</body>
</html>


<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/Mischlichter/data/main/gallerycom/65411740980.jpg">
    <title>HOGE AI</title>
    <style>
        @font-face {
            font-family: 'JetBrainsMono-Regular';
            src: url('fonts/JetBrainsMono-Regular.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Regular.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 400; /* Regular font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-Bold';
            src: url('fonts/JetBrainsMono-Bold.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Bold.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 700; /* Bold font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-BoldItalic';
            src: url('fonts/JetBrainsMono-BoldItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-BoldItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 700; /* Bold font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-ExtraBold';
            src: url('fonts/JetBrainsMono-ExtraBold.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-ExtraBold.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 800; /* Extra-bold font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-ExtraBoldItalic';
            src: url('fonts/JetBrainsMono-ExtraBoldItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-ExtraBoldItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 800; /* Extra-bold font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-ExtraLight';
            src: url('fonts/JetBrainsMono-ExtraLight.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-ExtraLight.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 200; /* Extra-light font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-ExtraLightItalic';
            src: url('fonts/JetBrainsMono-ExtraLightItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-ExtraLightItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 200; /* Extra-light font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-Italic';
            src: url('fonts/JetBrainsMono-Italic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Italic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 400; /* Regular font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-Light';
            src: url('fonts/JetBrainsMono-Light.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Light.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 300; /* Light font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-LightItalic';
            src: url('fonts/JetBrainsMono-LightItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-LightItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 300; /* Light font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-Medium';
            src: url('fonts/JetBrainsMono-Medium.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Medium.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 500; /* Medium font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-MediumItalic';
            src: url('fonts/JetBrainsMono-MediumItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-MediumItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 500; /* Medium font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-SemiBold';
            src: url('fonts/JetBrainsMono-SemiBold.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-SemiBold.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 600; /* Semi-bold font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-SemiBoldItalic';
            src: url('fonts/JetBrainsMono-SemiBoldItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-SemiBoldItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 600; /* Semi-bold font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-Thin';
            src: url('fonts/JetBrainsMono-Thin.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Thin.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 100; /* Thin font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-ThinItalic';
            src: url('fonts/JetBrainsMono-ThinItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-ThinItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 100; /* Thin font weight */
            font-style: italic;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            -webkit-font-smoothing: antialiased;
            
            -moz-osx-font-smoothing: grayscale;
            font-family: 'JetBrainsMono-Regular', sans-serif;
            background-color: black;
            color: #00ffcc;
            margin: 0;
            padding: 0;
            transition: color 0.3s ease;
            max-width: 100vw;
            overflow-x: hidden;
            
            touch-action: pan-y;
        }


        html {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            
            
        }

        html, body {
            /*background-color: black;*/
            color: #00ffcc; /* Green color */
            /*height: 100vh;*/
            margin: 0;
            padding: 0;
    
    
            scrollbar-width: none;
            scrollbar-color: transparent transparent;
        }

        body::-webkit-scrollbar {
            width: 12px;
        }

        body::-webkit-scrollbar-track {
            background: transparent;
            border-left: 6px solid transparent; /* Adjust the border width to match the thumb's width */
        }

        body::-webkit-scrollbar-thumb {
            background: transparent;
            pointer-events: none; /* Disable interactivity */
        }

        #iframeContainer {
            width: 100%;
            height: 100%;
            z-index: 1;
            position: relative;

            
        }
        #mouseOverlay {
            pointer-events: auto;
            z-index: 1;

        }

        #iframeContainer iframe {
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index:1;
        }

        

        
        
        /* Individual image containers */
        .flex-icontainer {
            opacity: 0;
            transition: opacity 1s ease-out;
            position: relative; /* Essential for absolute child positioning */
       
            padding-top: 38%; /* Same as width for a 1:1 aspect ratio */
            margin: 50px auto; /* Center horizontally */
            border: 2px solid #00ffcc; /* Green border */
            border-radius: 20px; /* Rounded corners */
            overflow: hidden; /* Ensures nothing spills outside the rounded corners */
            box-sizing: border-box;
            background-color: black;
            
            /* Removed flexbox styles since we're using absolute positioning for the image */
        }

        .flex-icontainer img {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%; /* Slightly larger than the container */
            height: 100%; /* Keep the image square and slightly larger */
            transform: translate(-50%, -50%); /* Center the image */
            object-fit: cover; /* Ensures the image covers the available area */
            
        }





        .flex-container {
            display: flex;
            flex-wrap: wrap;
            margin: 50px auto; /* Center horizontally */
            /*position: relative;
            bottom: 800px; */
            border: none;
            box-sizing: border-box;
            font-family: 'JetBrainsMono-Bold', sans-serif;
            text-transform: uppercase;
           
            z-index: 2;
        
            
            border: 2px solid #00ffcc; /* Green border */
            border-radius: 20px; /* Rounded corners */
            padding: 8px 15px; /* Adjust padding as needed */
            background-color: black;
            
            
        }
        
        .flex-container span {
            white-space: nowrap;
            display: inline-block;
            margin: 0 5px 5px 0;
            
        }





        #mainpage .dynamic-text { 
            opacity: 0;

        }
        
        #bodygallery .dynamic-text {
            z-index: 2;
        }
            
        
    

        .menu-bar {
            display: flex;
            justify-content: space-evenly; /* Evenly spaces the menu items */
            align-items: center;
            background-color: black; /* 20% grey color */
            border: 2px solid #00ffcc;
            border-radius: 20px;
            position: fixed; /* Fixed to the top */
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 30px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000; /* Ensures it stays on top of other content */

        }
        
        .menu-container {
            font-family: 'JetBrainsMono-Bold';
            font-size: 16px;
            margin: 0; /* Adjust as needed */
            /* Additional styles for your menu items */
        }
        .menu-container {
            margin: 0; /* Adjust as needed */
            cursor: default; /* Or 'pointer' if you want a hand cursor */
            user-select: none;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none;

        }
        
        @media screen and (max-width: 768px) {
            .menu-bar {
                display: flex; /* Enable flexbox */
                flex-wrap: wrap; /* Allow wrapping into new lines */
                padding: 5px; /* Adjust padding for mobile */
                justify-content: space-evenly; /* Space items evenly */
            }

            .menu-container {
                flex: 1 1 25%; /* Each item takes up to 25% of the width */
                box-sizing: border-box; /* Include padding and border in the width */
                text-align: left; /* Center text in each container */
                padding: 5px; /* Adjust padding for items */
                
            }
  
            .logo-small {
                position: absolute;
                left: 13.5%; /* 25% of the container's width is the first quarter */
                top: 50%;
                transform: translate(-50%, -50%); /* Center horizontally and vertically */
            }

         


        }





        .active-menu-item {
            font-family: 'JetBrainsMono-Bold'; /* Bold font */
            color: #fff; /* Change color if needed */
            /* Other styles to highlight the active item */
        }
        .menu-container {
            transition: transform 0.3s ease;
        }
        .menu-container:hover {
            transform: scale(1.1); /* Slightly enlarges the hovered item */
        }
        .content-above-iframe {
            padding: 20px;
        }
        .content-below-iframe {
            padding: 20px;
        }


        .foreground-image-container {
            position: absolute; /* or absolute, depending on your layout needs */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Ensures it is above all other content */
            pointer-events: none; /* Allows clicks to pass through to elements below */
        }

        .foreground-image {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Adjust this as necessary to fit your design */
        }







        :root {
          --viewer-width: 1024px;
          --viewer-height: 2048px;
          --total-width: 3072px; /* New variable for total width */

        }

        #interfaceContainer {
          position: absolute; /* or 'fixed' depending on use case */
          top: 50%;
          left: 50%;
          z-index: 15;
          transform: translate(-50%, -50%);
          width: var(--total-width); /* Assuming this is set to 3072px or as needed */
          height: var(--viewer-height); /* Assuming this is set to 2048px */
          margin: 0 auto; /* Center the container */

          pointer-events: none;
        }

        .sideImageContainer {
          background-size: cover;
          background-repeat: no-repeat;
          z-index: 15;

        }

   

        #interfaceSideLeft, #interfaceSideRight {
          position: absolute;
          top: 0;
          width: calc((var(--total-width) - var(--viewer-width)) / 2); /* Adjust width for side containers */
          height: 100%;
          

        }

        #interfaceSideLeft {
          left: 0;

        }

        #interfaceSideRight {
          right: 0;

        }

        #interfaceViewerContainer {
          position: absolute;
          top: 0;
          left: calc((100% - var(--viewer-width)) / 2); /* Center the viewer */
          width: var(--viewer-width);
          height: 100%;
          z-index: 15;
          display: flex;
          justify-content: center;
          align-items: center;
          pointer-events: none;
        }
        @media screen and (max-width: 768px) {
          #interfaceViewerContainer {
            top: 1%;
          }
        }


        #interfaceViewerImage {
          width: 100%;
          height: 100%;
          pointer-events: none;

        }


        :root {
            --background-total-width: 4096px;
            --background-total-height: 3072px;
        }

        #backgroundRoot {
            --viewer-width: 1024px;
            --viewer-height: 2048px;
            --total-width: 3072px; /* New variable for total width */
        }

        #backgroundContainer {
            position: absolute; /* or 'fixed' depending on use case */
            top: 50%;
            left: 50%;
            z-index: -2;
            transform: translate(-50%, -50%);
            width: var(--total-width); /* Assuming this is set to 3072px or as needed */
            height: var(--viewer-height); /* Assuming this is set to 2048px */
            margin: 0 auto; /* Center the container */
        }

        #backgroundInterfaceContainer {
            position: absolute;
            top: 0;
            left: calc((100% - var(--viewer-width)) / 2); /* Center the viewer */
            width: var(--viewer-width);
            height: 100%;
            z-index: -2;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #interfaceBackground {
            width: 100%;
            height: auto;

          
        }

        .scale-wrapper-background, .scale-wrapper-interface {
            position: absolute; /* Or 'fixed' if they should stay in place during scroll */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; /* Or an explicit height if necessary */
            pointer-events: none; /* To allow interaction with elements below */
        }

        .scale-wrapper-background {
            pointer-events: none;
            position: absolute; /* Switched to absolute for stronger positioning control */
            top: -15%;
            left: 50%;
            transform-origin: center center; /* Ensures scaling occurs from the element's center */
            width: fit-content; /* Ensures the wrapper fits the scaled content */
            height: fit-content; /* Ensures the wrapper fits the scaled content */
            transform: translate(-50%, -50%) scale(0.8); /* Centers and then scales the content */
        }

        .scale-wrapper-interface {
            pointer-events: none;
            position: absolute; /* Switched to absolute for stronger positioning control */
            top: 50%;
            left: 50%;
            transform-origin: center center; /* Ensures scaling occurs from the element's center */
            width: fit-content; /* Ensures the wrapper fits the scaled content */
            height: fit-content; /* Ensures the wrapper fits the scaled content */
            transform: translate(-50%, -50%) scale(0.8); /* Centers and then scales the content */
        }

        .scale-wrapper-background {
            z-index: -2; /* Ensures the background is placed behind other content */
        }

        .scale-wrapper-interface {
            z-index: 15; /* Ensures the interface is placed above the background */
        }

        #preloader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 10000;
            flex-direction: column;
        }
        #loadProgress {
            width: 80%;
            height: 30px;
            margin-top: 20px;
        }
        #enterSite {
            display: none;
            padding: 10px 20px;
            font-size: 20px;
            margin-top: 20px;
            cursor: pointer;
        }



    </style>
</head>
<body>
    
    <div id="preloader">
        <div>Loading, please wait...</div>
        <progress id="loadProgress" max="100" value="0"></progress>
        <button id="enterSite" onclick="enterSite()">Enter Site</button>
    </div>



    <div class="mainpage">

        </div>
        <div id="iframeContainer" style="position: relative; width: 100%; height: 100%;;z-index: 1;">
        <div id="mouseOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;z-index: 1;"></div>
 
    </div>

    <div id="bodyGalleryContainer">

    </div>
    
    <div class="scale-wrapper-background">
        <div id="backgroundRoot">
            <div id="backgroundContainer">
                <div id="backgroundInterfaceContainer">
                    <div id="interfaceBackground"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="scale-wrapper-interface">
        <div id="interfaceContainer">
            <div id="interfaceSideLeft" class="sideImageContainer"></div>
            <div id="interfaceViewerContainer">
                <img id="interfaceViewerImage" alt="Viewer Image">
            </div>
            <div id="interfaceSideRight" class="sideImageContainer"></div>
        </div>
    </div>


      
    </div>



    <div class="below-main"></div>
    <link rel="stylesheet" type="text/css" href="css/bodygallery.css">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.4/css/all.css" integrity="sha384-DyZ88mC6Up2uqS4h/KRgHuoeGwBcD4Ng9SiP4dIRy0EXTlnuz47vAwmeGwVChigm" crossorigin="anonymous">
    <script src="scripts/lenis.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>


    <script src="scripts/bodygallery.js"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('DOMContentLoaded event triggered');
            const ASSETS_MANIFEST_URL = 'https://raw.githubusercontent.com/Mischlichter/data/main/index.json';
            const EXTRA_ASSETS_URL = 'https://raw.githubusercontent.com/Mischlichter/data/main/assets/pagesi.txt';
            const cacheName = 'site-assets';
            const firstLoadCompleteFlag = 'firstLoadComplete';
            const secondLoadCompleteFlag = 'secondLoadComplete';

            async function preloadAssets() {
                console.log('Starting to preload assets');
                const cache = await caches.open(cacheName);
                console.log('Cache opened successfully');
                const [assets, extra] = await Promise.all([
                    fetch(ASSETS_MANIFEST_URL).then(res => res.json()),
                    fetch(EXTRA_ASSETS_URL).then(res => res.text())
                ]);
                console.log('Assets fetched successfully');

                const urlsToCache = [];
                parseAssets(assets, urlsToCache); // Parse through JSON object for URLs
                console.log('Assets parsed');

                const extraUrls = parseExtraAssets(extra); // Get additional URLs from pagesi.txt
                console.log('Extra assets parsed');

                const allUrls = [...urlsToCache, ...extraUrls];
                console.log(`Total URLs to cache: ${allUrls.length}`);
                let loaded = 0;

                for (let url of allUrls) {
                    try {
                        await cache.add(url);
                        loaded++;
                        console.log(`Cached: ${url}`);
                        if (!localStorage.getItem(secondLoadCompleteFlag)) {
                            document.getElementById('loadProgress').value = (loaded / allUrls.length) * 100;
                        }
                    } catch (error) {
                        console.error(`Could not cache ${url}: ${error}`);
                    }
                }

                await verifyCache(cache, allUrls);

                if (!localStorage.getItem(firstLoadCompleteFlag)) {
                    localStorage.setItem(firstLoadCompleteFlag, 'true');
                    window.location.reload();
                } else if (!localStorage.getItem(secondLoadCompleteFlag)) {
                    localStorage.setItem(secondLoadCompleteFlag, 'true');
                    window.location.reload();
                } else {
                    document.getElementById('enterSite').style.display = 'block'; // Show the enter button only after the second complete reload
                }
            }

            async function verifyCache(cache, urls) {
                console.log('Verifying cached assets');
                const cacheKeys = await cache.keys();
                let verifiedCount = 0;

                for (let url of urls) {
                    if (cacheKeys.some(request => request.url === url)) {
                        verifiedCount++;
                        console.log(`Verified: ${url}`);
                    } else {
                        console.error(`Verification failed for: ${url}`);
                    }
                }

                console.log(`Total verified URLs: ${verifiedCount}`);
            }

            function parseAssets(node, urls) {
                for (let key in node) {
                    if (node.hasOwnProperty(key)) {
                        const value = node[key];
                        if (typeof value === 'object') {
                            parseAssets(value, urls);
                        } else if (key.startsWith('Viewer') || key.startsWith('interface')) {
                            urls.push(`https://raw.githubusercontent.com/Mischlichter/data/main/${key}`);
                        }
                    }
                }
            }

            function parseExtraAssets(text) {
                return text.split('\n').filter(line => line.trim().startsWith('http')).map(line => line.trim());
            }

            function enterSite() {
                setTimeout(() => {
                    initializeMenu();
                    document.getElementById('preloader').style.display = 'none';
                }, 3000);
            }

            // Check and control the load progress visibility based on the phase of loading
            if (!localStorage.getItem(firstLoadCompleteFlag) || !localStorage.getItem(secondLoadCompleteFlag)) {
                preloadAssets();
            } else {
                document.getElementById('enterSite').style.display = 'block'; // Show the enter button after second load complete
                localStorage.removeItem(firstLoadCompleteFlag); // Clear flags after displaying the button
                localStorage.removeItem(secondLoadCompleteFlag);
            }

            document.getElementById('enterSite').addEventListener('click', enterSite);
        });


    </script>






    <script>
        
//////// MOUSE SMOOTHING ////////

        const lenis = new Lenis()

        lenis.on('scroll', (e) => {

          //console.log(e)
        })

        function raf(time) {
          lenis.raf(time)
          requestAnimationFrame(raf)
        }

        requestAnimationFrame(raf)

        function scrollToTop() {
            // Disable Lenis smooth scrolling
            lenis.stop();


            // Instantly set the scroll position to the top
            if (typeof window !== 'undefined') {
                window.scrollTo(0, 0);

                


            }

            // Re-enable Lenis smooth scrolling
            setTimeout(() => {
                lenis.start();
            }, 50); // Using setTimeout ensures this occurs in the next event loop cycle
        }

        

//////// Interface Loadin //////
        

        



//////// IFRAME LOADING ////////


        function updateIframe(sceneKey) {
            const iframeContainer = document.getElementById('iframeContainer');
            const mouseOverlay = document.getElementById('mouseOverlay');
            const bodyGalleryContainer = document.getElementById('bodyGalleryContainer');




            unhideElementsByClass("foreground-image-container");

            // Remove existing iframe and clear body gallery content
            let existingIframe = document.getElementById('sceneIframe');
            if (existingIframe) {
                existingIframe.remove(); // Remove the old iframe
            }
            if (bodyGalleryContainer) {
                bodyGalleryContainer.innerHTML = ''; // Clear body gallery content
            }

            if (sceneKey === 'scene04') {
                // Logic for scene04 (Gallery)
                toggleRemoveFooterActivation()
                resetRemoveStyledFooterCounter()
                iframeContainer.style.display = 'none';
                if (mouseOverlay) {
                    mouseOverlay.style.display = 'none';
                }
                bodyGalleryContainer.style.display = 'block';
                hideElementsByClass("foreground-image-container");
                loadGallery(); // Load the gallery for scene04
                unhideBackground();
                scrollToTop();

            } else if (sceneKey === 'scene05') {
                // Logic for scene05 (Clipz)
                hideElementsByClass("foreground-image-container");
                setupIframe('clipz2.html'); // Load clipz.html for scene05
            } else {
                // Logic for other scenes
                setupIframe(`depthyxx14.html?scene=${sceneKey}`);
            }

            function setupIframe(src) {
                
                iframeContainer.style.display = 'block';
                if (mouseOverlay) {
                    mouseOverlay.style.display = 'block';
                    mouseOverlay.style.zIndex = '1';
                }
                bodyGalleryContainer.style.display = 'none';

                let newIframe = document.createElement('iframe');
                newIframe.id = 'sceneIframe';
                newIframe.style.width = '100%';
                newIframe.style.height = '100vh';
                newIframe.style.border = 'none';
                newIframe.src = src;
                iframeContainer.appendChild(newIframe);

                hideBackground();
                scrollToTop();

            }
        }


        function hideElementsByClass(className) {
          // Get all elements with the specified class name
          var elements = document.getElementsByClassName(className);
          
          // Loop through each element
          for (var i = 0; i < elements.length; i++) {
            // Hide the current element by setting its display property to 'none'
            elements[i].style.display = 'none';
          }
        }

        function unhideElementsByClass(className) {
          // Get all elements with the specified class name
          var elements = document.getElementsByClassName(className);
          
          // Loop through each element
          for (var i = 0; i < elements.length; i++) {
            // Unhide the current element by setting its display property to its default value
            elements[i].style.display = '';
          }
        }



        function hideBackground() {
            setTimeout(() => {
                const background = document.querySelector('div[style*="background-color"]');
                if (background) {
                    background.remove(); // Remove the background element from the DOM
                }
                
                
            }, 111); // Delay of 500 milliseconds (adjust as needed)
        }



        function unhideBackground() {
            setTimeout(() => {
                const existingBackground = document.querySelector('div[style*="background-color"]');
                if (!existingBackground) {
                    const background = document.createElement('div');
                    background.style.position = 'absolute';
                    background.style.top = '0';
                    background.style.left = '0';
                    background.style.width = '100%';
                    background.style.height = '1vh';
                    background.style.zIndex = '-2';
                    background.style.backgroundColor = 'rgba(0, 0, 0, 0)'; // 10% grey
                    // Add more styles or content to the background as needed

                    document.body.insertBefore(background, document.body.firstChild);
                }
            }, 111); // Delay of 500 milliseconds
        }

 

        


//////// MOUSE HANDLING ///////////        

        // Initialize Variables
        var mouseX = 0, mouseY = 0;
        var targetMouseX = window.innerWidth / 2, targetMouseY = window.innerHeight / 2;
        var maxSmoothingFactor = 0.111; // Maximum smoothing factor
        var isMouseInArea = false;
        var applySmoothing = false;

        var mouseOverlay = document.getElementById('mouseOverlay');

        // Event Handlers
        function handleMouseEnter(e) {
            isMouseInArea = true;
            applySmoothing = true; // Enable smoothing on entering
            targetMouseX = e.clientX - mouseOverlay.offsetLeft - mouseOverlay.offsetWidth / 2;
            targetMouseY = e.clientY - mouseOverlay.offsetTop - mouseOverlay.offsetHeight / 2;
            
        }

        function handleMouseLeave(e) {
            isMouseInArea = false;
        }

        function handleMouseMove(e) {
            targetMouseX = e.clientX - mouseOverlay.offsetLeft - mouseOverlay.offsetWidth / 2;
            targetMouseY = e.clientY - mouseOverlay.offsetTop - mouseOverlay.offsetHeight / 2;
        }

        // Attach Event Listeners
        mouseOverlay.addEventListener('mouseenter', handleMouseEnter);
        mouseOverlay.addEventListener('mouseleave', handleMouseLeave);
        mouseOverlay.addEventListener('mousemove', handleMouseMove);

        // Animation Frame Function
        function animate() {
            if (applySmoothing) {
                var dx = targetMouseX - mouseX;
                var dy = targetMouseY - mouseY;
                var distance = Math.sqrt(dx * dx + dy * dy);
                var smoothingFactor = Math.min(distance / 100, maxSmoothingFactor); // Dynamic smoothing factor

                mouseX += dx * smoothingFactor;
                mouseY += dy * smoothingFactor;

                // Disable smoothing when close enough
                if (distance < 1) {
                    applySmoothing = false;
                    mouseX = targetMouseX;
                    mouseY = targetMouseY;
                }
            } else {
                mouseX = targetMouseX;
                mouseY = targetMouseY;
            }

            sendMouseEventToIframe('mousemove', { clientX: mouseX, clientY: mouseY });
            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);

        // Update sendMouseEventToIframe to use coordinates
        function sendMouseEventToIframe(eventType, event) {
            const iframe = document.getElementById('sceneIframe');
            if (iframe && iframe.contentWindow) {
                //console.log('Sending event to iframe:', eventType, mouseX, mouseY);
                iframe.contentWindow.postMessage({
                    type: eventType,
                    mouseX: mouseX,
                    mouseY: mouseY
                }, '*');
            }
        }
        



        document.addEventListener('DOMContentLoaded', (event) => {
            const background = document.createElement('div');
            background.style.position = 'absolute';
            background.style.top = '0';
            background.style.left = '0';
            background.style.width = '100%';
            background.style.height = '50000vh';
            background.style.zIndex = '-2';
            background.style.backgroundColor = 'rgba(0, 0, 0, 0)'; // 10% grey
            // Add more styles or content to the background as needed

            document.body.insertBefore(background, document.body.firstChild);
        });


//////// IMAGE LOADING ////////////////////

        let currentSceneData = null;

        async function fetchAndParseData() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/Mischlichter/data/main/assets/pages.txt');
                const text = await response.text();
                return parseText(text);
            } catch (error) {
                return null;
            }
        }

        


        function parseText(text) {
            //console.log("Original text:", text); // Print the original text

            // Split the text into scenes
            let scenes = text.split(/SCENE\d+:/);
            //console.log("Scenes after initial split:", scenes); // Print scenes after initial split

            // Remove the first empty element if it exists
            if (scenes[0].trim() === '') {
                scenes.shift();
            }

            let parsedData = [];

            scenes.forEach((scene, index) => {
                //console.log(`Processing scene ${index + 1}:`, scene); // Print the current scene being processed

                let sceneData = {
                    sceneKey: `scene${index + 1}`,
                    containers: {},
                    numberOfContainers: 0
                };

                // Split the scene into paragraphs and CSS
                let parts = scene.split(/#container\d+ \{/);
                //console.log(`Parts for scene ${index + 1}:`, parts); // Print the parts after splitting by container

                // First part is always paragraphs. Exclude the paragraph numbers.
                let paragraphs = parts[0].trim()
                    .split(/\n+\s*P\d+:?\s*/) // Split at paragraph markers, optional colon
                    .filter(p => p) // Remove empty strings from the array
                    .map((paragraph, index) => 
                        index === 0 ? paragraph.replace(/^P\d+:?\s*/, '').trim() : paragraph.trim()
                    );



                //console.log(`Paragraphs for scene ${index + 1}:`, paragraphs); // Print the paragraphs for the current scene

                // Calculate the number of containers
                sceneData.numberOfContainers = paragraphs.length;

                // Process CSS and associate with paragraphs
                for (let i = 1; i <= sceneData.numberOfContainers; i++) {
                    let css = parts[i] ? `#container${i.toString().padStart(2, '0')} {` + parts[i].split('}')[0].trim() + '}' : '';
                    let containerKey = `container${i.toString().padStart(2, '0')}`;
                    sceneData.containers[containerKey] = {
                        text: paragraphs[i - 1],
                        style: css
                    };
                    //console.log(`Container ${containerKey} for scene ${index + 1}:`, sceneData.containers[containerKey]); // Print each container's data
                }

                parsedData.push(sceneData);
            });

            //console.log("Parsed data:", parsedData); // Print the final parsed data
            return parsedData;
        }



        async function fetchImage() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/Mischlichter/data/main/assets/pagesi.txt');
                const text = await response.text();
                return parseImage(text);
            } catch (error) {
                return null;
            }
        }

        
        function parseImage(text) {
            //console.log("Starting image parsing...");

            // Split the text into scenes
            let scenes = text.split(/SCENE\d+:/);
            //console.log("Scenes identified:", scenes.length);

            // Remove the first empty element if it exists
            if (scenes[0].trim() === '') {
                scenes.shift();
                //console.log("Removed empty first element.");
            }

            let parsedImageData = [];

            scenes.forEach((scene, index) => {
                //console.log(`Processing scene ${index + 1}`);

                let sceneImageData = {
                    sceneKey: `scene${index + 1}`,
                    images: {}
                };

                // Extract image URLs and their CSS
                let imageMatches = scene.matchAll(/\n\nI\d+:\n(https?:\/\/\S+)/g);
                let cssMatches = scene.matchAll(/#i-container\d+ \{([\s\S]*?)\}/g);

                let cssStyles = {};
                for (const cssMatch of cssMatches) {
                    let cssKey = cssMatch[0].match(/#i-container(\d+)/)[1];
                    cssStyles[`i-container${cssKey.padStart(2, '0')}`] = cssMatch[1].trim();
                }

                for (const imageMatch of imageMatches) {
                    let imageNumber = imageMatch[0].match(/I(\d+)/)[1];
                    let imageKey = `i-container${imageNumber.padStart(2, '0')}`;
                    let imageCSS = cssStyles[imageKey] || '';

                    sceneImageData.images[imageKey] = {
                        src: imageMatch[1].trim(),
                        style: imageCSS
                    };
                    //console.log(`Found image: ${imageKey} -> ${imageMatch[1].trim()}, CSS: ${imageCSS}`);
                }

                parsedImageData.push(sceneImageData);
            });

            //console.log("Image parsing complete:", parsedImageData);
            return parsedImageData;
        }





//////// MENU LOADING //////////


        let isAnimating = false;

        function initializeMenu() {
            fetchAndParseMenuData().then(menuData => {
                if (menuData && menuData.length > 0) {
                    loadMenu(menuData);
                }
            });
        }



        async function fetchAndParseMenuData() {
            try {
                //console.log("Fetching menu data...");
                const response = await fetch('https://raw.githubusercontent.com/Mischlichter/data/main/assets/menu.txt');
                const text = await response.text();
                return parseMenuText(text);
            } catch (error) {
                //console.error("Error fetching menu data:", error);
                return [];
            }
        }

        function parseMenuText(text) {
            //console.log("Parsing menu text...");
            let menuItems = text.split('\n').filter(line => line.trim() !== '');
            return menuItems.map(item => {
                let [label, scene] = item.split(':');
                return { label, scene };
            });
        }

        let menuContainerIds = []; // Global or accessible scope

        function loadMenu(menuData) {
            isAnimating = true;
            
            setTimeout(() => {
                isAnimating = false;
            }, 4000); // 3000 milliseconds = 3 seconds
            
            // Create or clear the menu bar
            let menuBar = document.querySelector('.menu-bar');
            if (!menuBar) {
                menuBar = document.createElement('div');
                menuBar.className = 'menu-bar';
                document.body.appendChild(menuBar);
            } else {
                menuBar.innerHTML = ''; // Clear existing content
            }

            // Insert logo image at the start of the menu bar
            const logoImg = document.createElement('img');
            logoImg.src = 'https://raw.githubusercontent.com/Mischlichter/data/main/interface/logo.png';
            logoImg.style.marginRight = '20px';
            logoImg.id = 'menuLogo'; // Assign an ID for easy reference
            menuBar.appendChild(logoImg);

            // Clear existing menu container IDs
            menuContainerIds = [];

            // Create new containers for each menu item
            menuData.forEach((menuItem, index) => {
                const menuContainer = document.createElement('div');
                menuContainer.id = `menuContainer${index}`;
                menuContainer.className = 'menu-container';
                menuContainer.innerText = menuItem.label; // Display the label
                menuBar.appendChild(menuContainer); // Append to the menu bar

                // Add click event listener to load the corresponding scene
                menuContainer.addEventListener('click', () => {
                    currentSceneIndex = index; // Update the current scene index
                    loadScene(currentSceneIndex); // Load the selected scene
                    highlightActiveMenuItem(`menuContainer${index}`);
                });

                // Add hover event listener
                menuContainer.addEventListener('mouseover', () => animateTextDuringHover(menuContainer));

                // To trigger the hover effect on the first menu container after 3 seconds
                if (index === 0 || index === 3) {
                    setTimeout(() => {
                        animateTextDuringHover(menuContainer);
                    }, 8000); // 3000 milliseconds = 3 seconds
                }

                // Add the new container ID to the array
                menuContainerIds.push(menuContainer.id);
            });

            // Insert fake menu items
            
                const fakeMenuItem1 = document.createElement('div');
                fakeMenuItem1.className = 'menu-container';
                fakeMenuItem1.setAttribute('data-fake', 'true'); // Mark as fake
                fakeMenuItem1.innerText = '';
                menuBar.insertBefore(fakeMenuItem1, menuBar.children[1]); // Insert after the logo

                const fakeMenuItem2 = document.createElement('div');
                fakeMenuItem2.className = 'menu-container';
                fakeMenuItem2.setAttribute('data-fake', 'true'); // Mark as fake
                fakeMenuItem2.innerText = '';
                menuBar.insertBefore(fakeMenuItem2, menuBar.children[5]); // Insert after the third real menu item
                 // Insert after the third real menu item
          

            // Call updateMenu at the end
            updateMenu(menuData);
            updateLogoVisibility();
        }

        function updateLogoVisibility() {
            const logoImg = document.getElementById('menuLogo');
            // Select only fake menu items using the data-fake attribute
            const fakeMenuItems = document.querySelectorAll('.menu-container[data-fake="true"]');

            if (window.innerWidth <= 768) {
                logoImg.src = 'https://raw.githubusercontent.com/Mischlichter/data/main/interface/logoS.png'; 
                logoImg.classList.add('logo-small');
                fakeMenuItems.forEach(item => item.style.display = '');
            } else {
                logoImg.src = 'https://raw.githubusercontent.com/Mischlichter/data/main/interface/logo.png'; 
                logoImg.classList.remove('logo-small');
                fakeMenuItems.forEach(item => item.style.display = 'none'); // Use empty string to reset the display property
            }
        }








//////// ANIMATION MENU ///////

        function updateMenu(menuData) {
            //console.log("Updating menu...");
            preparedMenuItems = {}; // Resetting for the new menu

            
            menuData.forEach((menuItem, index) => {
                let containerId = `menuContainer${index}`;
                let textLines = menuItem.label.split('\n'); // Changed from menuItem.title to menuItem.label
                //console.log("Preparing menu item:", menuItem.label);
                let lineSpans = createSpansForMenu(containerId, textLines.join(' '));
                preparedMenuItems[containerId] = lineSpans;
            });

            // Resetting the current animation index for menu
            currentContainerIndex = 0;
            containerIds = Object.keys(preparedMenuItems);



            startAllMenuAnimations();


        }


        function createSpansForMenu(containerId, text) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            //console.log("Creating spans for menu:", containerId);

            let tempSpan = document.createElement('span');
            tempSpan.style.display = 'inline-block';
            tempSpan.style.visibility = 'hidden';
            document.body.appendChild(tempSpan);

            let style = window.getComputedStyle(container);
            let paddingAndBorder = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) +
                                   parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
            let availableWidth = container.clientWidth - paddingAndBorder - 5;

            let lines = [];
            let currentLine = '';
            text.split(' ').forEach(word => {
                let testLine = currentLine + word + ' ';
                tempSpan.innerText = testLine;

                if (tempSpan.offsetWidth > availableWidth && currentLine !== '') {
                    let lineContainer = createLineContainerForMenu(container, currentLine.trim());
                    lines.push(lineContainer);
                    currentLine = word + ' ';
                } else {
                    currentLine = testLine;
                }
            });

            if (currentLine.trim() !== '') {
                let lineContainer = createLineContainerForMenu(container, currentLine.trim());
                lines.push(lineContainer);
            }

            document.body.removeChild(tempSpan);
            return lines;
        }

        function createLineContainerForMenu(container, lineText) {
            let lineContainer = document.createElement('div');
            lineContainer.style.display = 'inline-block';
            lineContainer.style.width = '100%';
            container.appendChild(lineContainer);

            //console.log("Creating line container for:", lineText);

            lineText.split(' ').forEach(word => {
                if (word.trim() !== '') {
                    var wordSpan = document.createElement('span');
                    wordSpan.className = 'dynamic-text';
                    wordSpan.setAttribute('data-final-text', word);
                    wordSpan.style.opacity = '0';
                    lineContainer.appendChild(wordSpan);
                }
            });

            return lineContainer;

        }

        function startAnimationForMenuContainer(containerId) {
            ///console.log("Starting animation for container:", containerId);
            if (preparedMenuItems[containerId]) {
                startLineAnimation(preparedMenuItems[containerId]);
            } else {
                //console.log("No prepared data for container:", containerId);
            }
        }


        function startAllMenuAnimations() {
            menuContainerIds.forEach(containerId => {
                startAnimationForMenuContainer(containerId);

            if (containerId === 'menuContainer0') {
                initializeFirstScene();
            }
            });
        }

        function initializeFirstScene() {
            currentSceneIndex = 0; // Set to the first scene
            loadScene(currentSceneIndex); // Load the first scene
        }


        function shuffleMenu() {
            let menuItems = document.querySelectorAll('.menu-container');
            
            menuItems.forEach(menuItem => {
                if (!menuItem.dataset.originalText) {
                    menuItem.dataset.originalText = menuItem.textContent;
                }
                //console.log("Original text:", menuItem.dataset.originalText); // Log original text
                animateMenuDuringScaling(menuItem, menuItem.dataset.originalText);
            });
        }


        function animateMenuDuringScaling(element, finalText) {
            var totalDuration = 300; // Total duration of the scrambling
            var randomStartDelay = Math.random() * 200; // Start scrambling with random delay
            var stopScramblingDelay = totalDuration - 200 + Math.random() * 400; // When to stop scrambling
            var startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                var progress = timestamp - startTime;

                if (progress < stopScramblingDelay) {
                    var scrambledText = generateRandomString(finalText.length);
                    element.textContent = scrambledText;
                    //console.log("Scrambled text:", scrambledText); // Log scrambled text
                    requestAnimationFrame(step);
                } else {
                    element.textContent = finalText;
                    element.style.opacity = '1';
                    //console.log("Final text set to:", element.textContent); // Log final text
                    if (progress >= totalDuration) {
                        element.removeAttribute('data-originalText'); // Clean up
                    }
                }
            }

            setTimeout(function() {
                requestAnimationFrame(step);
            }, randomStartDelay);
        }

        function animateTextDuringHover(element, finalDuration = 150) {
            // Check if an animation is in progress
            if (isAnimating) {
                ///console.log("Animation already in progress. Hover animation blocked.");
                return; // Exit the function if an animation is already happening
            }

            // Capture the original text only if it has not been stored yet
            if (!element.dataset.originalText) {
                element.dataset.originalText = element.textContent;
            }

            var originalText = element.dataset.originalText; // Use the stored original text

            var startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                var progress = timestamp - startTime;

                if (progress < finalDuration) {
                    // Scramble text
                    var scrambledText = generateRandomString(originalText.length);
                    element.textContent = scrambledText;
                    requestAnimationFrame(step);
                } else {
                    // Revert back to the original text
                    element.textContent = originalText;
                }
            }

            requestAnimationFrame(step);
        }

        // Attach the event listener to each menu item for hover animation
        document.querySelectorAll('.menu-container').forEach(item => {
            item.addEventListener('mouseover', () => animateTextDuringHover(item));
        });




        function highlightActiveMenuItem(activeMenuItemId) {
            // Remove active class from all menu items
            document.querySelectorAll('.menu-container').forEach(item => {
                item.classList.remove('active-menu-item');
            });

            // Add active class to the current menu item
            const activeItem = document.getElementById(activeMenuItemId);
            if (activeItem) {
                activeItem.classList.add('active-menu-item');
            }
        }

//////// SZENE LOADER /////////////////////////////////////////////////////////////////////////


        let currentSceneIndex = 0;
        let scenesData = [];
        let scenesiData = [];

        async function initialize() {
            scenesData = await fetchAndParseData();
            if (scenesData && scenesData.length > 0) {
                loadScene(currentSceneIndex);
            
            }
            scenesiData = await fetchImage();
            if (scenesiData && scenesiData.length > 0) {
                loadScene(currentSceneIndex);
            
            }

        }




        // Keep track of dynamically added style elements
        const dynamicStyles = [];

        function clearDynamicStyles() {
          dynamicStyles.forEach(style => style.remove());
          dynamicStyles.length = 0; // Clear the array
        }

        function loadScene(index) {
            const scene = scenesData[index];
            const sceneImages = scenesiData[index]; // Assuming scenesiData is structured similarly

            if (!scene) return;

            // Remove all existing containers and dynamic styles
            const existingContainers = document.querySelectorAll('.flex-container, .flex-icontainer');
            existingContainers.forEach(container => container.remove());

            // Clear dynamic styles
            clearDynamicStyles();

            loadInterface(index);

            let formattedSceneKey = scene.sceneKey.length === 6 ? `scene0${scene.sceneKey.charAt(5)}` : scene.sceneKey;

            // Update the iframe with the new scene
            updateIframe(formattedSceneKey);
            //console.log('Formatted Scene Key:', formattedSceneKey);
            // Merge and sort text and image containers
            let combinedData = [];
            Object.keys(scene.containers).forEach(key => {
                combinedData.push({ type: 'text', key: key, content: scene.containers[key] });
            });

            if (sceneImages && sceneImages.images) {
                Object.keys(sceneImages.images).forEach(key => {
                    combinedData.push({ type: 'image', key: key, content: sceneImages.images[key] });
                });
            }

            combinedData.sort((a, b) => {
                let numA = parseInt(a.key.match(/\d+/)[0], 10);
                let numB = parseInt(b.key.match(/\d+/)[0], 10);
                return numA - numB || (a.type === 'text' ? -1 : 1);
            });

            // Create containers in sorted order
            combinedData.forEach(item => {
                const container = document.createElement('div');
                container.id = item.key;
                container.className = item.type === 'text' ? 'flex-container' : 'flex-icontainer';
                document.body.appendChild(container);

                if (item.type === 'text') {
                    attachLinkToContainer(container, item.content.style);
                }

                const style = document.createElement('style');
                style.innerHTML = item.content.style;
                document.head.appendChild(style);
                dynamicStyles.push(style);

                if (item.type === 'image') {
                    const image = document.createElement('img');
                    image.src = item.content.src;
                    container.appendChild(image);
                }
            });

            // Create and style the footer
            createStyledFooter()

            currentSceneData = scene;

            // Update containers when loading a new scene
            updateAllContainers(scene);

            highlightActiveMenuItem(`menuContainer${index}`);
            observeImagesForAnimation();
        }

        function extractLinkFromCSS(css) {
            const linkPattern = /\/\* link: (.*) \*\//; // Pattern to extract URL from comment
            const match = css.match(linkPattern);
            if (match) {
                //console.log("Extracted link:", match[1].trim());
                return match[1].trim();
            } else {
                //console.log("No link found in CSS.");
                return null;
            }
        }

        function attachLinkToContainer(container, css) {
            const link = extractLinkFromCSS(css);
            if (link) {
                //console.log("Attaching link", link, "to container", container.id);
                container.style.cursor = 'pointer'; // Changes the cursor to pointer to indicate it's clickable
                container.onclick = () => window.open(link, '_blank'); // Opens the link in a new tab when clicked
            }
        }




        function createStyledFooter() {
            removeStyledFooter();
            const footerContainer = document.createElement('div');
            footerContainer.id = 'customStyledFooter';
            footerContainer.style.width = '100vw'; // Width of the viewport
            footerContainer.style.height = '5000px'; // Footer height
            footerContainer.style.backgroundColor = 'black'; // Footer background color
            footerContainer.style.color = 'white'; // Text color
            footerContainer.style.display = 'flex'; // Use flexbox for layout
            footerContainer.style.flexDirection = 'column'; // Stack items vertically
            footerContainer.style.alignItems = 'center'; // Center items horizontally
            footerContainer.style.justifyContent = 'center'; // Center items vertically
            footerContainer.style.position = 'relative'; // To apply z-index
            footerContainer.style.zIndex = '30'; // Ensure it's on top
            footerContainer.style.marginTop = '256px'; // Space before the footer
            footerContainer.style.boxShadow = '0px -50px 30px -20px rgba(0, 0, 0, 0.5)';

            footerContainer.innerHTML = `
                <div style="display: flex; align-items: flex-start; justify-content: center; flex-wrap: wrap; margin-top: -4900px;">
                    <a class="btn btn-outline-light btn-floating m-1" href="#!" role="button" style="color: white; margin: 0 10px;"><i class="fab fa-facebook-f"></i></a>
                    <a class="btn btn-outline-light btn-floating m-1" href="#!" role="button" style="color: white; margin: 0 10px;"><i class="fab fa-twitter"></i></a>
                    <a class="btn btn-outline-light btn-floating m-1" href="#!" role="button" style="color: white; margin: 0 10px;"><i class="fab fa-google"></i></a>
                    <a class="btn btn-outline-light btn-floating m-1" href="#!" role="button" style="color: white; margin: 0 10px;"><i class="fab fa-instagram"></i></a>
                    <a class="btn btn-outline-light btn-floating m-1" href="#!" role="button" style="color: white; margin: 0 10px;"><i class="fab fa-linkedin-in"></i></a>
                    <a class="btn btn-outline-light btn-floating m-1" href="#!" role="button" style="color: white; margin: 0 10px;"><i class="fab fa-github"></i></a>
                </div>
                <div style="margin-top: 5px;">
                     2024 Copyright: <a class="text-white" href="https://HogeAI.com/" style="color: white;">HogeAI.com</a>
                </div>
            `;
            document.body.appendChild(footerContainer);

            function preventScrollBeyondFooter() {
                // Calculate the maximum Y position users should be able to scroll to
                // This is the document's height minus the viewport's height and the footer's height
                const maxScrollY = document.body.offsetHeight - window.innerHeight - footerContainer.offsetHeight + 111; // 256px is the margin top of the footer

                if (window.scrollY > maxScrollY) {
                    // If the user scrolls beyond the max Y position, smoothly scroll them back to the max Y position
                    window.scrollTo({
                        top: maxScrollY,
                        behavior: 'smooth'
                    });
                }
            }

            // Call the function right away in case the page is already scrolled beyond the footer
            preventScrollBeyondFooter();

            // Add a 'scroll' event listener to the window to invoke the function whenever the user scrolls
            window.addEventListener('scroll', preventScrollBeyondFooter);
        }


        // Flag to control the activation of footer removal
        let isRemoveFooterActive = false;

        // Function to toggle the removal activation
        function toggleRemoveFooterActivation() {
            isRemoveFooterActive = !isRemoveFooterActive;
            //console.log(`RemoveStyledFooter is now ${isRemoveFooterActive ? 'active' : 'inactive'}.`);
        }

        // Modified removeStyledFooter function
        let removeStyledFooterCounter = 0; // Initialize a counter for the function calls

        function removeStyledFooter() {
            // Check if the action is active
            if (!isRemoveFooterActive) {
                //console.log('RemoveStyledFooter is inactive. Exiting function.');
                return; // Exit the function if not active
            }
            
            const footerContainer = document.getElementById('customStyledFooter');
            if (footerContainer) {
                document.body.removeChild(footerContainer);
                //console.log('Styled footer removed.');
                removeStyledFooterCounter++; // Increment the counter after a successful removal
                
                // Check if the function has run 2 times
                if (removeStyledFooterCounter >= 2) {
                    isRemoveFooterActive = false; // Deactivate the function
                    //console.log('RemoveStyledFooter has been set to inactive after running 2 times.');
                }
                
            } else {
                //console.log('No styled footer found to remove.');
            }
        }


        function resetRemoveStyledFooterCounter() {
            removeStyledFooterCounter = 0;
            //console.log('The counter for removeStyledFooter has been reset.');
        }



        function observeImagesForAnimation() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = 1; // Trigger the fade-in animation
                    }
                });
            }, {
                threshold: 0.3 // This means the animation will start when 10% of the item is visible
            });

            const images = document.querySelectorAll('.flex-icontainer');
            images.forEach(image => observer.observe(image));
        }


        





        function createVerticalTiles_a(containerId, imageUrl, imageHeight) {
            const container = document.getElementById(containerId);
            container.innerHTML = ''; // Clear existing content

            // Assuming the container's height is directly based on its content (the images)
            // We calculate the number of tiles needed to fill the container plus one for overflow
            const numTiles = 11; // Since you mentioned wanting about 10 tiles

            for (let i = 0; i < numTiles; i++) {
                const img = document.createElement('img');
                img.src = imageUrl;
                img.style.position = 'absolute';
                img.style.top = `${i * imageHeight}px`;
                img.style.left = 0;
                img.style.width = '100%'; // Stretch the image to fill the container's width
                img.style.height = `${imageHeight}px`; // Set a fixed height for direct tiling
                container.appendChild(img);
                requestAnimationFrame(updateParallax);
                
                // This function needs to be called to update the virtual canvas size accordingly
                delayedVirtualCanvasUpdate();
            }
        }



        function createVerticalTiles_b(containerId, imageUrl, imageHeight) {
            const container = document.getElementById(containerId);
            container.innerHTML = ''; // Clear existing content

            // Assuming the container's height is directly based on its content (the images)
            // We calculate the number of tiles needed to fill the container plus one for overflow
            const numTiles = 11; // Since you mentioned wanting about 10 tiles

            for (let i = 0; i < numTiles; i++) {
                const img = document.createElement('img');
                img.src = imageUrl;
                img.style.position = 'absolute';
                img.style.top = `${i * imageHeight}px`;
                img.style.left = 0;
                img.style.width = '100%'; // Stretch the image to fill the container's width
                img.style.height = `${imageHeight}px`; // Set a fixed height for direct tiling
                container.appendChild(img);
                
                
                updateVirtualCanvasSize();
            }
        }

        function delayedVirtualCanvasUpdate() {
            // Delay the call to updateVirtualCanvasSize
            setTimeout(updateVirtualCanvasSize, 100); // Delay of 100 milliseconds
        }

        function loadInterface(currentSceneIndex) {
            // Extend: Function to ensure wrapper existence
            function ensureWrapperExistence(wrapperClass, contentStructure) {
                let wrapper = document.querySelector(`.${wrapperClass}`);
                if (!wrapper) {
                    wrapper = document.createElement('div');
                    wrapper.className = wrapperClass;
                    document.body.appendChild(wrapper); // Append wrapper to the body
                    wrapper.innerHTML = contentStructure; // Set the inner HTML as per the structure required
                }
            }

            // For scene index 3, remove the wrappers completely
            if (currentSceneIndex === 3 || currentSceneIndex === 4) {
                document.querySelectorAll('.scale-wrapper-background, .scale-wrapper-interface').forEach(wrapper => {
                    wrapper.parentNode.removeChild(wrapper);
                });
                return; // Exit the function after handling the special case for scene index 3
            }

            // Ensure the existence of `.scale-wrapper-background` and `.scale-wrapper-interface` wrappers
            ensureWrapperExistence('scale-wrapper-background', `
                <div id="backgroundRoot">
                    <div id="backgroundContainer">
                        <div id="backgroundInterfaceContainer">
                            <div id="interfaceBackground"></div>
                        </div>
                    </div>
                </div>
            `);

            ensureWrapperExistence('scale-wrapper-interface', `
                <div id="interfaceContainer">
                    <div id="interfaceSideLeft" class="sideImageContainer"></div>
                    <div id="interfaceViewerContainer">
                        <img id="interfaceViewerImage" alt="Viewer Image">
                    </div>
                    <div id="interfaceSideRight" class="sideImageContainer"></div>
                </div>
            `);

            // Your existing code to tile images and update the viewer image
            const sceneFormatted = currentSceneIndex.toString().padStart(2, '0');
            const imageHeight = 2048; // Fixed height for all images

            const backgroundUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/background/b${sceneFormatted}.png`;
            const sideImageUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/side/s${sceneFormatted}.png`;
            const viewerImageUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/viewer/v${sceneFormatted}.png`;
            const viewerMaskUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/viewer/viewermask.png`;

            createVerticalTiles_a('interfaceBackground', backgroundUrl, imageHeight);
            createVerticalTiles_b('interfaceSideLeft', sideImageUrl, imageHeight);
            createVerticalTiles_b('interfaceSideRight', sideImageUrl, imageHeight);

            const viewerImageElement = document.getElementById('interfaceViewerImage');
            if (viewerImageElement) {
                viewerImageElement.src = viewerImageUrl;
                viewerImageElement.style.maskImage = `url('${viewerMaskUrl}')`;
                viewerImageElement.style.webkitMaskImage = `url('${viewerMaskUrl}')`;
                viewerImageElement.style.maskSize = 'cover';
                viewerImageElement.style.webkitMaskSize = 'cover';
            }
        }

        let lastScrollY = 0;

        function updateParallax() {
            // One-time iOS device check to exit the function if on an iOS device
            const isiOS = /iPad|iPhone|iPod/.test(navigator.platform) || 
                          (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            if (isiOS) {
                return; // Exit the function early if on an iOS device
            }

            const speedFactorBackground = 0.3; // Slower background movement
            const speedFactorSides = -1.2; // Faster side images movement, negative for upward scroll
            const speedFactorViewer = -0.3; // Viewer image movement speed, matching scroll speed for a floating effect

            // Parallax effect updates for background, sides, and viewer container
            const background = document.getElementById('interfaceBackground');
            if (background) {
                const offsetBackground = window.scrollY * speedFactorBackground;
                background.style.transform = `translateY(${offsetBackground}px)`;
            }

            const sideLeft = document.getElementById('interfaceSideLeft');
            const sideRight = document.getElementById('interfaceSideRight');
            if (sideLeft && sideRight) {
                const offsetSides = window.scrollY * speedFactorSides;
                sideLeft.style.transform = `translateY(${offsetSides}px)`;
                sideRight.style.transform = `translateY(${offsetSides}px)`;
            }

            const viewerContainer = document.getElementById('interfaceViewerContainer');
            if (viewerContainer) {
                const offsetViewer = window.scrollY * speedFactorViewer;
                viewerContainer.style.transform = `translateY(${offsetViewer}px)`;
            }

            // Continue the animation only if any of the parallax elements are present
            if (background || sideLeft || sideRight || viewerContainer) {
                requestAnimationFrame(updateParallax);
            }
        }

        window.addEventListener('load', () => {
            loadInterface(0); // Load with the initial scene index
            requestAnimationFrame(updateParallax);
        });









/////////// ANIMATION TEXT /////

        function generateRandomString(length) {
            var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*()[]{}|';
            var randomString = '';
            for (var i = 0; i < length; i++) {
                randomString += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return randomString;
        }

        function animateText(element, finalText, duration, delay) {
            setTimeout(function() {
                var currentText = generateRandomString(finalText.length);
                element.textContent = currentText;
                element.style.opacity = '0';

                var shuffleFrequency = 10;
                var intervalTime = duration / (finalText.length * shuffleFrequency);
                var index = 0;
                var shuffleCount = 0;
                var startTime = null;

                function step(timestamp) {
                    if (!startTime) startTime = timestamp;
                    var progress = timestamp - startTime;

                    if (progress > intervalTime) {
                        if (shuffleCount % shuffleFrequency === 0 && index < finalText.length) {
                            currentText = currentText.substring(0, index) + finalText.charAt(index) + generateRandomString(finalText.length - index - 1);
                            index++;
                        } else {
                            currentText = currentText.substring(0, index) + generateRandomString(finalText.length - index);
                        }
                        element.textContent = currentText;
                        shuffleCount++;
                        element.style.opacity = Math.min(1, parseFloat(element.style.opacity) + 0.05);

                        let colorTransitionFactor = index / finalText.length;
                        let startColor = { r: 7, g: 247, b: 139 }; // #07f78b
                        let endColor = { r: 0, g: 255, b: 204 };   // #7cfc05
                        let r = Math.floor(startColor.r + (endColor.r - startColor.r) * colorTransitionFactor);
                        let g = Math.floor(startColor.g + (endColor.g - startColor.g) * colorTransitionFactor);
                        let b = Math.floor(startColor.b + (endColor.b - startColor.b) * colorTransitionFactor);
                        element.style.color = `rgb(${r}, ${g}, ${b})`;

                        if (index === finalText.length && shuffleCount % shuffleFrequency === 0) {
                            element.textContent = finalText;
                            element.style.opacity = '1';
                            element.style.color = `rgb(${endColor.r}, ${endColor.g}, ${endColor.b})`; // Final color
                            return; // Stop the animation
                        }
                        startTime = timestamp;
                    }
                    requestAnimationFrame(step);
                }

                requestAnimationFrame(step);
            }, delay);
        }

        function createSpansForContainer(containerId, text) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            let tempSpan = document.createElement('span');
            tempSpan.style.display = 'inline-block';
            tempSpan.style.visibility = 'hidden';
            document.body.appendChild(tempSpan);

            let style = window.getComputedStyle(container);
            let paddingAndBorder = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) +
                                   parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
            let availableWidth = container.clientWidth - paddingAndBorder - 5;

            // Calculate 10% additional width
            let additionalWidth = availableWidth * 0.095;
            let extendedWidth = availableWidth + additionalWidth;

            let lines = [];
            let currentLine = '';
            text.split(' ').forEach(word => {
                let testLine = currentLine + word + ' ';
                tempSpan.innerText = testLine;

                // Use extendedWidth for the condition
                if (tempSpan.offsetWidth > extendedWidth && currentLine !== '') {
                    let lineContainer = createLineContainer(container, currentLine.trim());
                    lines.push(lineContainer);
                    currentLine = word + ' ';
                } else {
                    currentLine = testLine;
                }
            });

            if (currentLine.trim() !== '') {
                let lineContainer = createLineContainer(container, currentLine.trim());
                lines.push(lineContainer);
            }

            document.body.removeChild(tempSpan);
            return lines;
        }

        function createLineContainer(container, lineText) {
            adjustContainerSizesBasedOnVirtualCanvas();
            let lineContainer = document.createElement('div');
            lineContainer.style.display = 'inline-block';
            lineContainer.style.width = '1000%';
            container.appendChild(lineContainer);
            lineContainer.style.whiteSpace = 'nowrap';
            lineText.split(' ').forEach(word => {
                if (word.trim() !== '') {
                    var wordSpan = document.createElement('span');
                    wordSpan.className = 'dynamic-text';
                    wordSpan.setAttribute('data-final-text', word);
                    wordSpan.style.opacity = '0';
                    lineContainer.appendChild(wordSpan);
                }
            });

            return lineContainer;
        }

        function startLineAnimation(lineContainers) {
            let wordDelayIncrement = 100;
            let lineStartDelay = 150;

            // Pre-populate line containers with blank spaces or invisible characters
            lineContainers.forEach(lineContainer => {
                Array.from(lineContainer.children).forEach(wordSpan => {
                    wordSpan.textContent = '\u00A0'; // Non-breaking space
                });
            });

            // Start the animation by replacing the placeholders with actual text
            lineContainers.forEach((lineContainer, lineIndex) => {
                Array.from(lineContainer.children).forEach((wordSpan, wordIndex) => {
                    let totalDelay = (lineIndex * lineStartDelay) + (wordIndex * wordDelayIncrement);
                    setTimeout(() => {
                        animateText(wordSpan, wordSpan.getAttribute('data-final-text'), 1000);
                    }, totalDelay);
                });
            });
        }


////////ANIMATION SCALING

        let preparedContainers = {};

        function updateAllContainers(Scene) {

            preparedContainers = {}; // Resetting for the new Scene
            Object.keys(Scene.containers).forEach(containerId => {

                let containerData = Scene.containers[containerId];
                let textLines = containerData.text.split('\n');
                let lineSpans = createSpansForContainer(containerId, textLines.join(' '));
                preparedContainers[containerId] = lineSpans;
            });

            // Resetting the current animation index
            currentContainerIndex = 0;
            containerIds = Object.keys(Scene.containers);

        }

        function startAnimationForContainer(containerId) {
            //console.log("Starting animation for container:", containerId);
            if (preparedContainers[containerId]) {
                startLineAnimation(preparedContainers[containerId]);
            } else {
                //console.log("No prepared data for container:", containerId);
            }
        }
      
        function checkAndInitialize() {
            const container01 = document.getElementById('container01');
            if (container01.clientWidth > 0) {
                updateAllContainers();
            } else {
                setTimeout(checkAndInitialize, 50);
            }
        }

        function animateTextDuringScaling(element, finalText) {
            var currentText = generateRandomString(finalText.length);
            element.textContent = currentText;
            element.style.opacity = '1';

            var totalDuration = 300;  // Total duration of the scrambling
            var randomStartDelay = Math.random() * 200;  // Start scrambling with random delay
            var stopScramblingDelay = totalDuration - 200 + Math.random() * 400;  // Stop scrambling with random delay
            var startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                var progress = timestamp - startTime;

                if (progress < stopScramblingDelay) {
                    currentText = generateRandomString(finalText.length);
                    element.textContent = currentText;
                    requestAnimationFrame(step);
                } else {
                    element.textContent = finalText;
                }
            }

            setTimeout(function() {
                requestAnimationFrame(step);
            }, randomStartDelay);
        }

        function startScalingAnimation(lineContainers) {
            lineContainers.forEach(lineContainer => {
                Array.from(lineContainer.children).forEach(wordSpan => {
                    animateTextDuringScaling(wordSpan, wordSpan.getAttribute('data-final-text'));
                });
            });
        }
 
        function updateAllContainersDuringScaling() {
            if (!currentSceneData) {
                return; // Exit if not set
            }
            const savedScrollPosition = window.scrollY;
            // Use currentSceneData for scaling animation
            Object.keys(currentSceneData.containers).forEach(containerId => {
                let containerData = currentSceneData.containers[containerId];
                let textLines = containerData.text.split('\n');
                let lineSpans = createSpansForContainer(containerId, textLines.join(' '));
                startScalingAnimation(lineSpans);
            });
            window.scrollTo(0, savedScrollPosition);
        }
        
        window.addEventListener('resize', function() {
            // Check if the device is iOS
            var iOS = /iPad|iPhone|iPod/.test(navigator.platform) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

            // Exclude this code from running on iOS devices
            if(iOS) {
                return; // Exit the function if on an iOS device
            }

            if (isAnimating) {
                return; // Exit the function if an animation is already happening
            }
            updateAllContainersDuringScaling();
            
            shuffleMenu();
        });


        function checkAndStartAnimationsOnScroll() {
            const viewportHeight = window.innerHeight;
            const triggerHeight = viewportHeight / 1.05; // 1/4 of the viewport height

            containerIds.forEach(containerId => {
                const container = document.getElementById(containerId);
                if (container) {
                    const rect = container.getBoundingClientRect();
                    if (rect.top <= triggerHeight && !container.dataset.animationStarted) {
                        startAnimationForContainer(containerId);
                        container.dataset.animationStarted = 'true'; // Mark as animated
                    }
                }
            });
        }

        

        function getSmoothAspectRatio(viewportWidth, viewportHeight) {
            const portraitAspectRatio = 1.6; 
            const landscapeAspectRatio = 1.9; 

            const currentAspectRatio = viewportWidth / viewportHeight;

            if (currentAspectRatio < 1) {
                return portraitAspectRatio;
            } else if (currentAspectRatio >= 1 && currentAspectRatio < 4 / 3) {
                let t = (currentAspectRatio - 1) / (4 / 3 - 1);
                return portraitAspectRatio + t * (landscapeAspectRatio - portraitAspectRatio);
            } else {
                return landscapeAspectRatio;
            }
        }

        var lastScaleFactor = null; // Tracks the last scale factor for portrait mode
        var cumulativeScaleChange = 0; // Accumulates scale changes for portrait mode

        function updateVirtualCanvasSize() {
            var virtualcanvas = document.getElementById('virtualcanvas');
            if (!virtualcanvas) {
                virtualcanvas = document.createElement('div');
                virtualcanvas.id = 'virtualcanvas';
                document.body.appendChild(virtualcanvas);
                // Ensure elements are prepared for smooth transitions
                virtualcanvas.style.transition = 'transform 0.5s ease';
            }

            var viewportWidth = window.innerWidth;
            var viewportHeight = window.innerHeight;
            var isPortrait = viewportWidth < viewportHeight;
            var smoothAspectRatio = getSmoothAspectRatio(viewportWidth, viewportHeight);
            var fixedAspectRatio = 1536 / 1024; // Fixed aspect ratio

            var canvasWidth, canvasHeight;
            if (isPortrait) {
                canvasHeight = viewportHeight / smoothAspectRatio;
                canvasWidth = canvasHeight * fixedAspectRatio;
            } else {
                canvasWidth = viewportWidth;
                canvasHeight = canvasWidth / smoothAspectRatio;
            }

            var size = { width: canvasWidth, height: canvasHeight };

            var scaleFactor = Math.min(size.width / 1536, size.height / 1024);

            // Apply the scale factor for all modes without checking for changes
            document.querySelectorAll('.scale-wrapper-background, .scale-wrapper-interface').forEach(element => {
                element.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
            });

            // Update the virtual canvas size
            virtualcanvas.style.width = size.width + 'px';
            virtualcanvas.style.height = size.height + 'px';
            virtualcanvas.style.left = '50%';
            virtualcanvas.style.position = 'absolute';
            virtualcanvas.style.transform = 'translate(-50%, -50%)';
            virtualcanvas.style.top = '50%';
            virtualcanvas.style.zIndex = '-100';


        }

        function adjustContainerSizesBasedOnVirtualCanvas() {
            var virtualCanvas = document.getElementById('virtualcanvas');
            if (!virtualCanvas) {
                //console.error('Virtual canvas not found.');
                return;
            }

            var virtualCanvasWidth = virtualCanvas.offsetWidth;

            // Determine if we are likely on a mobile device based on viewport width
            var isMobile = window.innerWidth <= 768; // Mobile threshold

            // Detect orientation for mobile devices
            var isPortrait = window.innerHeight > window.innerWidth;
            
            // Default to base width percentage for design
            var baseWidthPercent = 39;

            // Define mobile adjustments: Adjust these values as needed for your design
            var portraitAdjustment = 1.3; // 45% wider on mobile in portrait
            var landscapeAdjustment = 1; // 20% wider on mobile in landscape

            // Select the appropriate adjustment factor based on mobile status and orientation
            var adjustmentFactor = 1; // Default for non-mobile or desktop
            if (isMobile) {
                adjustmentFactor = isPortrait ? portraitAdjustment : landscapeAdjustment;
            }

            var scaledWidthPx = (virtualCanvasWidth * baseWidthPercent / 100) * adjustmentFactor; // Apply selected adjustment

            var flexContainers = document.querySelectorAll('.flex-container, .flex-icontainer');
            flexContainers.forEach(function(container) {
                // Set width adjusted for mobile orientation or use default for desktop
                container.style.width = scaledWidthPx + 'px';

                // For .flex-icontainer, adjust padding-top to maintain aspect ratio
                if (container.classList.contains('flex-icontainer')) {
                    container.style.paddingTop = scaledWidthPx + 'px';
                }
            });
        }

        document.addEventListener('touchend', function() {
            setTimeout(() => {
                // Only reset horizontal scroll if it's greater than a certain threshold
                if (window.scrollX > 0) {
                    window.scrollTo(0, window.scrollY);
                }
            }, 100); // Delay in milliseconds
        }, { passive: true });


        // Prevent pinch-zoom in mobile browsers
        document.addEventListener('touchmove', function(event) {
          if (event.scale !== 1) { event.preventDefault(); }
        }, { passive: false });

        // Prevent scroll-zoom in desktop browsers
        document.addEventListener('wheel', function(event) {
          if (event.ctrlKey) { event.preventDefault(); }
        }, { passive: false });

        document.addEventListener('touchstart', function(event) {
          if (event.touches.length > 1) {
            event.preventDefault();
          }
        }, { passive: false });
    
        // Add event listener to resize in case the viewport size changes
        window.addEventListener('resize', updateVirtualCanvasSize);

        window.addEventListener('scroll', checkAndStartAnimationsOnScroll);
        
        window.addEventListener('resize', updateLogoVisibility);

        


        initialize();
    </script>
</body>
</html>

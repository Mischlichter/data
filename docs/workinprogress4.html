<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="https://raw.githubusercontent.com/Mischlichter/data/main/gallerycom/65411740980.jpg">
    <title>HOGE AI</title>
    <style>
        @font-face {
            font-family: 'JetBrainsMono-Regular';
            src: url('fonts/JetBrainsMono-Regular.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Regular.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 400; /* Regular font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-Bold';
            src: url('fonts/JetBrainsMono-Bold.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Bold.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 700; /* Bold font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-BoldItalic';
            src: url('fonts/JetBrainsMono-BoldItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-BoldItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 700; /* Bold font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-ExtraBold';
            src: url('fonts/JetBrainsMono-ExtraBold.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-ExtraBold.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 800; /* Extra-bold font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-ExtraBoldItalic';
            src: url('fonts/JetBrainsMono-ExtraBoldItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-ExtraBoldItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 800; /* Extra-bold font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-ExtraLight';
            src: url('fonts/JetBrainsMono-ExtraLight.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-ExtraLight.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 200; /* Extra-light font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-ExtraLightItalic';
            src: url('fonts/JetBrainsMono-ExtraLightItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-ExtraLightItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 200; /* Extra-light font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-Italic';
            src: url('fonts/JetBrainsMono-Italic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Italic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 400; /* Regular font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-Light';
            src: url('fonts/JetBrainsMono-Light.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Light.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 300; /* Light font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-LightItalic';
            src: url('fonts/JetBrainsMono-LightItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-LightItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 300; /* Light font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-Medium';
            src: url('fonts/JetBrainsMono-Medium.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Medium.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 500; /* Medium font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-MediumItalic';
            src: url('fonts/JetBrainsMono-MediumItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-MediumItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 500; /* Medium font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-SemiBold';
            src: url('fonts/JetBrainsMono-SemiBold.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-SemiBold.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 600; /* Semi-bold font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-SemiBoldItalic';
            src: url('fonts/JetBrainsMono-SemiBoldItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-SemiBoldItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 600; /* Semi-bold font weight */
            font-style: italic;
        }

        @font-face {
            font-family: 'JetBrainsMono-Thin';
            src: url('fonts/JetBrainsMono-Thin.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-Thin.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 100; /* Thin font weight */
            font-style: normal;
        }

        @font-face {
            font-family: 'JetBrainsMono-ThinItalic';
            src: url('fonts/JetBrainsMono-ThinItalic.woff2') format('woff2'), /* Modern Browsers */
                 url('fonts/JetBrainsMono-ThinItalic.ttf') format('truetype'); /* Safari, Android, iOS */
            font-weight: 100; /* Thin font weight */
            font-style: italic;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            -webkit-font-smoothing: antialiased;
            -webkit-overflow-scrolling: touch;
            -moz-osx-font-smoothing: grayscale;
            font-family: 'JetBrainsMono-Regular', sans-serif;
            background-color: black;
            color: #00ffcc;
            margin: 0;
            padding: 0;
            transition: color 0.3s ease;
            max-width: 100vw;
            overflow-x: hidden;
        }


        html {
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            
            
        }

        html, body {
            /*background-color: black;*/
            color: #00ffcc; /* Green color */
            /*height: 100vh;*/
            margin: 0;
            padding: 0;
    
    
            scrollbar-width: none;
            scrollbar-color: transparent transparent;
        }

        body::-webkit-scrollbar {
            width: 12px;
        }

        body::-webkit-scrollbar-track {
            background: transparent;
            border-left: 6px solid transparent; /* Adjust the border width to match the thumb's width */
        }

        body::-webkit-scrollbar-thumb {
            background: transparent;
            pointer-events: none; /* Disable interactivity */
        }

        #iframeContainer {
            width: 100%;
            height: 100%;
            z-index: 1;
            position: relative;

            
        }
        #mouseOverlay {
            pointer-events: auto;
            z-index: 1;

        }

        #iframeContainer iframe {
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index:1;
        }

     
        
        
        /* Individual image containers */
        .flex-icontainer {
            opacity: 0;
            transition: opacity 1s ease-out;
            position: relative; /* Essential for absolute child positioning */
       
            padding-top: 38%; /* Same as width for a 1:1 aspect ratio */
            margin: 50px auto; /* Center horizontally */
            border: 2px solid #00ffcc; /* Green border */
            border-radius: 20px; /* Rounded corners */
            overflow: hidden; /* Ensures nothing spills outside the rounded corners */
            box-sizing: border-box;
            background-color: black;
            /* Removed flexbox styles since we're using absolute positioning for the image */
        }

        .flex-icontainer img {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 105%; /* Slightly larger than the container */
            height: 105%; /* Keep the image square and slightly larger */
            transform: translate(-50%, -50%); /* Center the image */
            object-fit: cover; /* Ensures the image covers the available area */
        }





        .flex-container {
            display: flex;
            flex-wrap: wrap;
            margin: 50px auto; /* Center horizontally */
            /*position: relative;
            bottom: 800px; */
            border: none;
            box-sizing: border-box;
            font-family: 'JetBrainsMono-Bold', sans-serif;
            text-transform: uppercase;
           
            z-index: 2;
            pointer-events: none;
            
            border: 2px solid #00ffcc; /* Green border */
            border-radius: 20px; /* Rounded corners */
            padding: 8px 15px; /* Adjust padding as needed */
            background-color: black;
            
        }
        
        .flex-container span {
            white-space: nowrap;
            display: inline-block;
            margin: 0 5px 5px 0;
        }





        #mainpage .dynamic-text { 
            opacity: 0;

        }
        
        #bodygallery .dynamic-text {
            z-index: 2;
        }
            
        
        .hide-logo {
            display: none;
        }

        .menu-bar {
            display: flex;
            justify-content: space-evenly; /* Evenly spaces the menu items */
            align-items: center;
            background-color: black; /* 20% grey color */
            border: 2px solid #00ffcc;
            border-radius: 20px;
            position: fixed; /* Fixed to the top */
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px 30px;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
            z-index: 1000; /* Ensures it stays on top of other content */

        }
        
        .menu-container {
            font-family: 'JetBrainsMono-Bold';
            font-size: 16px;
            margin: 0; /* Adjust as needed */
            /* Additional styles for your menu items */
        }
        .menu-container {
            margin: 0; /* Adjust as needed */
            cursor: default; /* Or 'pointer' if you want a hand cursor */
            user-select: none;
            -webkit-user-select: none; /* Safari */
            -moz-user-select: none; /* Firefox */
            -ms-user-select: none;

        }
        
        @media screen and (max-width: 768px) {
            .menu-bar {
                display: flex; /* Enable flexbox */
                flex-wrap: wrap; /* Allow wrapping into new lines */
                padding: 5px; /* Adjust padding for mobile */
                justify-content: space-evenly; /* Space items evenly */
            }

            .menu-container {
                flex: 1 1 30%; /* Each item takes up to 50% of the width */
                box-sizing: border-box; /* Include padding and border in the width */
                text-align: center; /* Center text in each container */
                padding: 5px; /* Adjust padding for items */
            }
        }
        .active-menu-item {
            font-family: 'JetBrainsMono-Bold'; /* Bold font */
            color: #fff; /* Change color if needed */
            /* Other styles to highlight the active item */
        }
        .menu-container {
            transition: transform 0.3s ease;
        }
        .menu-container:hover {
            transform: scale(1.1); /* Slightly enlarges the hovered item */
        }
        .content-above-iframe {
            padding: 20px;
        }
        .content-below-iframe {
            padding: 20px;
        }


        .foreground-image-container {
            position: absolute; /* or absolute, depending on your layout needs */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1; /* Ensures it is above all other content */
            pointer-events: none; /* Allows clicks to pass through to elements below */
        }

        .foreground-image {
            width: 100%;
            height: 100%;
            object-fit: cover; /* Adjust this as necessary to fit your design */
        }







        :root {
          --viewer-width: 1024px;
          --viewer-height: 2048px;
          --total-width: 3072px; /* New variable for total width */

        }

        #interfaceContainer {
          position: absolute; /* or 'fixed' depending on use case */
          top: 50%;
          left: 50%;
          z-index: 15;
          transform: translate(-50%, -50%);
          width: var(--total-width); /* Assuming this is set to 3072px or as needed */
          height: var(--viewer-height); /* Assuming this is set to 2048px */
          margin: 0 auto; /* Center the container */

          pointer-events: none;
        }

        .sideImageContainer {
          background-size: cover;
          background-repeat: no-repeat;
          z-index: 15;

        }

   

        #interfaceSideLeft, #interfaceSideRight {
          position: absolute;
          top: 0;
          width: calc((var(--total-width) - var(--viewer-width)) / 2); /* Adjust width for side containers */
          height: 100%;
          

        }

        #interfaceSideLeft {
          left: 0;

        }

        #interfaceSideRight {
          right: 0;

        }

        #interfaceViewerContainer {
          position: absolute;
          top: 0;
          left: calc((100% - var(--viewer-width)) / 2); /* Center the viewer */
          width: var(--viewer-width);
          height: 100%;
          z-index: 15;
          display: flex;
          justify-content: center;
          align-items: center;
          pointer-events: none;
        }

        #interfaceViewerImage {
          width: 100%;
          height: 100%;
          pointer-events: none;

        }


        :root {
            --background-total-width: 4096px;
            --background-total-height: 3072px;
        }

        #backgroundRoot {
            --viewer-width: 1024px;
            --viewer-height: 2048px;
            --total-width: 3072px; /* New variable for total width */
        }

        #backgroundContainer {
            position: absolute; /* or 'fixed' depending on use case */
            top: 50%;
            left: 50%;
            z-index: -2;
            transform: translate(-50%, -50%);
            width: var(--total-width); /* Assuming this is set to 3072px or as needed */
            height: var(--viewer-height); /* Assuming this is set to 2048px */
            margin: 0 auto; /* Center the container */
        }

        #backgroundInterfaceContainer {
            position: absolute;
            top: 0;
            left: calc((100% - var(--viewer-width)) / 2); /* Center the viewer */
            width: var(--viewer-width);
            height: 100%;
            z-index: -2;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #interfaceBackground {
            width: 100%;
            height: auto;

          
        }

        .scale-wrapper-background, .scale-wrapper-interface {
            position: absolute; /* Or 'fixed' if they should stay in place during scroll */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; /* Or an explicit height if necessary */
            pointer-events: none; /* To allow interaction with elements below */
        }

        .scale-wrapper-background {
            pointer-events: none;
            position: absolute; /* Switched to absolute for stronger positioning control */
            top: -15%;
            left: 50%;
            transform-origin: center center; /* Ensures scaling occurs from the element's center */
            width: fit-content; /* Ensures the wrapper fits the scaled content */
            height: fit-content; /* Ensures the wrapper fits the scaled content */
            transform: translate(-50%, -50%) scale(0.8); /* Centers and then scales the content */
        }

        .scale-wrapper-interface {
            pointer-events: none;
            position: absolute; /* Switched to absolute for stronger positioning control */
            top: 50%;
            left: 50%;
            transform-origin: center center; /* Ensures scaling occurs from the element's center */
            width: fit-content; /* Ensures the wrapper fits the scaled content */
            height: fit-content; /* Ensures the wrapper fits the scaled content */
            transform: translate(-50%, -50%) scale(0.8); /* Centers and then scales the content */
        }

        .scale-wrapper-background {
            z-index: -2; /* Ensures the background is placed behind other content */
        }

        .scale-wrapper-interface {
            z-index: 15; /* Ensures the interface is placed above the background */
        }



    </style>
</head>
<body>
    


    <div class="mainpage">

        </div>
        <div id="iframeContainer" style="position: relative; width: 100%; height: 100%;;z-index: 1;">
        <div id="mouseOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;z-index: 1;"></div>
 
    </div>

    <div id="bodyGalleryContainer">

    </div>
    
    <div class="scale-wrapper-background">
        <div id="backgroundRoot">
            <div id="backgroundContainer">
                <div id="backgroundInterfaceContainer">
                    <div id="interfaceBackground"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="scale-wrapper-interface">
        <div id="interfaceContainer">
            <div id="interfaceSideLeft" class="sideImageContainer"></div>
            <div id="interfaceViewerContainer">
                <img id="interfaceViewerImage" alt="Viewer Image">
            </div>
            <div id="interfaceSideRight" class="sideImageContainer"></div>
        </div>
    </div>





    <div class="below-main"></div>
    <link rel="stylesheet" type="text/css" href="css/bodygallery.css">
    
    <script src="scripts/lenis.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.5.1/gsap.min.js"></script>


    <script src="scripts/bodygallery.js"></script>
    
    <script>
        
//////// MOUSE SMOOTHING ////////

        const lenis = new Lenis()

        lenis.on('scroll', (e) => {
          //console.log(e)
        })

        function raf(time) {
          lenis.raf(time)
          requestAnimationFrame(raf)
        }

        requestAnimationFrame(raf)

        function scrollToTop() {
            // Disable Lenis smooth scrolling
            lenis.stop();

            // Instantly set the scroll position to the top
            if (typeof window !== 'undefined') {
                window.scrollTo(0, 0);
            }

            // Re-enable Lenis smooth scrolling
            setTimeout(() => {
                lenis.start();
            }, 50); // Using setTimeout ensures this occurs in the next event loop cycle
        }

        

//////// Interface Loadin //////
        

        



//////// IFRAME LOADING ////////


        function updateIframe(sceneKey) {
            const iframeContainer = document.getElementById('iframeContainer');
            const mouseOverlay = document.getElementById('mouseOverlay');
            const bodyGalleryContainer = document.getElementById('bodyGalleryContainer');

            unhideElementsByClass("foreground-image-container");

            // Remove existing iframe and clear body gallery content
            let existingIframe = document.getElementById('sceneIframe');
            if (existingIframe) {
                existingIframe.remove(); // Remove the old iframe
            }
            if (bodyGalleryContainer) {
                bodyGalleryContainer.innerHTML = ''; // Clear body gallery content
            }

            if (sceneKey === 'scene04') {
                // Logic for scene04 (Gallery)
               
                iframeContainer.style.display = 'none';
                if (mouseOverlay) {
                    mouseOverlay.style.display = 'none';
                }
                bodyGalleryContainer.style.display = 'block';
                hideElementsByClass("foreground-image-container");
                loadGallery(); // Load the gallery for scene04
                unhideBackground();
                scrollToTop();
            } else if (sceneKey === 'scene05') {
                // Logic for scene05 (Clipz)
                hideElementsByClass("foreground-image-container");
                setupIframe('clipz2.html'); // Load clipz.html for scene05
            } else {
                // Logic for other scenes
                setupIframe(`depthyxx14.html?scene=${sceneKey}`);
            }

            function setupIframe(src) {
                iframeContainer.style.display = 'block';
                if (mouseOverlay) {
                    mouseOverlay.style.display = 'block';
                    mouseOverlay.style.zIndex = '1';
                }
                bodyGalleryContainer.style.display = 'none';

                let newIframe = document.createElement('iframe');
                newIframe.id = 'sceneIframe';
                newIframe.style.width = '100%';
                newIframe.style.height = '100vh';
                newIframe.style.border = 'none';
                newIframe.src = src;
                iframeContainer.appendChild(newIframe);

                hideBackground();
                scrollToTop();
            }
        }


        function hideElementsByClass(className) {
          // Get all elements with the specified class name
          var elements = document.getElementsByClassName(className);
          
          // Loop through each element
          for (var i = 0; i < elements.length; i++) {
            // Hide the current element by setting its display property to 'none'
            elements[i].style.display = 'none';
          }
        }

        function unhideElementsByClass(className) {
          // Get all elements with the specified class name
          var elements = document.getElementsByClassName(className);
          
          // Loop through each element
          for (var i = 0; i < elements.length; i++) {
            // Unhide the current element by setting its display property to its default value
            elements[i].style.display = '';
          }
        }



        function hideBackground() {
            setTimeout(() => {
                const background = document.querySelector('div[style*="background-color"]');
                if (background) {
                    background.remove(); // Remove the background element from the DOM
                }
                
                
            }, 111); // Delay of 500 milliseconds (adjust as needed)
        }



        function unhideBackground() {
            setTimeout(() => {
                const existingBackground = document.querySelector('div[style*="background-color"]');
                if (!existingBackground) {
                    const background = document.createElement('div');
                    background.style.position = 'absolute';
                    background.style.top = '0';
                    background.style.left = '0';
                    background.style.width = '100%';
                    background.style.height = '1vh';
                    background.style.zIndex = '-2';
                    background.style.backgroundColor = 'rgba(0, 0, 0, 0)'; // 10% grey
                    // Add more styles or content to the background as needed

                    document.body.insertBefore(background, document.body.firstChild);
                }
            }, 111); // Delay of 500 milliseconds
        }

 

        


//////// MOUSE HANDLING ///////////        

        // Initialize Variables
        var mouseX = 0, mouseY = 0;
        var targetMouseX = window.innerWidth / 2, targetMouseY = window.innerHeight / 2;
        var maxSmoothingFactor = 0.111; // Maximum smoothing factor
        var isMouseInArea = false;
        var applySmoothing = false;

        var mouseOverlay = document.getElementById('mouseOverlay');

        // Event Handlers
        function handleMouseEnter(e) {
            isMouseInArea = true;
            applySmoothing = true; // Enable smoothing on entering
            targetMouseX = e.clientX - mouseOverlay.offsetLeft - mouseOverlay.offsetWidth / 2;
            targetMouseY = e.clientY - mouseOverlay.offsetTop - mouseOverlay.offsetHeight / 2;
            
        }

        function handleMouseLeave(e) {
            isMouseInArea = false;
        }

        function handleMouseMove(e) {
            targetMouseX = e.clientX - mouseOverlay.offsetLeft - mouseOverlay.offsetWidth / 2;
            targetMouseY = e.clientY - mouseOverlay.offsetTop - mouseOverlay.offsetHeight / 2;
        }

        // Attach Event Listeners
        mouseOverlay.addEventListener('mouseenter', handleMouseEnter);
        mouseOverlay.addEventListener('mouseleave', handleMouseLeave);
        mouseOverlay.addEventListener('mousemove', handleMouseMove);

        // Animation Frame Function
        function animate() {
            if (applySmoothing) {
                var dx = targetMouseX - mouseX;
                var dy = targetMouseY - mouseY;
                var distance = Math.sqrt(dx * dx + dy * dy);
                var smoothingFactor = Math.min(distance / 100, maxSmoothingFactor); // Dynamic smoothing factor

                mouseX += dx * smoothingFactor;
                mouseY += dy * smoothingFactor;

                // Disable smoothing when close enough
                if (distance < 1) {
                    applySmoothing = false;
                    mouseX = targetMouseX;
                    mouseY = targetMouseY;
                }
            } else {
                mouseX = targetMouseX;
                mouseY = targetMouseY;
            }

            sendMouseEventToIframe('mousemove', { clientX: mouseX, clientY: mouseY });
            requestAnimationFrame(animate);
        }

        requestAnimationFrame(animate);

        // Update sendMouseEventToIframe to use coordinates
        function sendMouseEventToIframe(eventType, event) {
            const iframe = document.getElementById('sceneIframe');
            if (iframe && iframe.contentWindow) {
                //console.log('Sending event to iframe:', eventType, mouseX, mouseY);
                iframe.contentWindow.postMessage({
                    type: eventType,
                    mouseX: mouseX,
                    mouseY: mouseY
                }, '*');
            }
        }
        



        document.addEventListener('DOMContentLoaded', (event) => {
            const background = document.createElement('div');
            background.style.position = 'absolute';
            background.style.top = '0';
            background.style.left = '0';
            background.style.width = '100%';
            background.style.height = '50000vh';
            background.style.zIndex = '-2';
            background.style.backgroundColor = 'rgba(0, 0, 0, 0)'; // 10% grey
            // Add more styles or content to the background as needed

            document.body.insertBefore(background, document.body.firstChild);
        });


//////// IMAGE LOADING ////////////////////

        let currentSceneData = null;

        async function fetchAndParseData() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/Mischlichter/data/main/pages.txt');
                const text = await response.text();
                return parseText(text);
            } catch (error) {
                return null;
            }
        }

        


        function parseText(text) {

            // Split the text into scenes
            let scenes = text.split(/SCENE\d+:/);

            // Remove the first empty element if it exists
            if (scenes[0].trim() === '') {
                scenes.shift();
            }

            let parsedData = [];

            scenes.forEach((scene, index) => {

                let sceneData = {
                    sceneKey: `scene${index + 1}`,
                    containers: {},
                    numberOfContainers: 0
                };

                // Split the scene into paragraphs and CSS
                let parts = scene.split(/#container\d+ \{/);
                
                // First part is always paragraphs. Exclude the paragraph numbers.
                let paragraphs = parts[0].trim().split(/\n\nP\d+:\n/).filter(p => p).map(paragraph => paragraph.replace(/P\d+:\n/, '').trim());

                // Calculate the number of containers
                sceneData.numberOfContainers = paragraphs.length;

                // Process CSS and associate with paragraphs
                for (let i = 1; i <= sceneData.numberOfContainers; i++) {
                    let css = parts[i] ? `#container${i.toString().padStart(2, '0')} {` + parts[i].split('}')[0].trim() + '}' : '';
                    let containerKey = `container${i.toString().padStart(2, '0')}`;
                    sceneData.containers[containerKey] = {
                        text: paragraphs[i - 1],
                        style: css
                    };
                }

                parsedData.push(sceneData);
            });

            return parsedData;
        }


        async function fetchImage() {
            try {
                const response = await fetch('https://raw.githubusercontent.com/Mischlichter/data/main/pagesi.txt');
                const text = await response.text();
                return parseImage(text);
            } catch (error) {
                return null;
            }
        }

        
        function parseImage(text) {
            console.log("Starting image parsing...");

            // Split the text into scenes
            let scenes = text.split(/SCENE\d+:/);
            console.log("Scenes identified:", scenes.length);

            // Remove the first empty element if it exists
            if (scenes[0].trim() === '') {
                scenes.shift();
                console.log("Removed empty first element.");
            }

            let parsedImageData = [];

            scenes.forEach((scene, index) => {
                console.log(`Processing scene ${index + 1}`);

                let sceneImageData = {
                    sceneKey: `scene${index + 1}`,
                    images: {}
                };

                // Extract image URLs and their CSS
                let imageMatches = scene.matchAll(/\n\nI\d+:\n(https?:\/\/\S+)/g);
                let cssMatches = scene.matchAll(/#i-container\d+ \{([\s\S]*?)\}/g);

                let cssStyles = {};
                for (const cssMatch of cssMatches) {
                    let cssKey = cssMatch[0].match(/#i-container(\d+)/)[1];
                    cssStyles[`i-container${cssKey.padStart(2, '0')}`] = cssMatch[1].trim();
                }

                for (const imageMatch of imageMatches) {
                    let imageNumber = imageMatch[0].match(/I(\d+)/)[1];
                    let imageKey = `i-container${imageNumber.padStart(2, '0')}`;
                    let imageCSS = cssStyles[imageKey] || '';

                    sceneImageData.images[imageKey] = {
                        src: imageMatch[1].trim(),
                        style: imageCSS
                    };
                    console.log(`Found image: ${imageKey} -> ${imageMatch[1].trim()}, CSS: ${imageCSS}`);
                }

                parsedImageData.push(sceneImageData);
            });

            console.log("Image parsing complete:", parsedImageData);
            return parsedImageData;
        }





//////// MENU LOADING //////////


        let isAnimating = false;

        function initializeMenu() {
            fetchAndParseMenuData().then(menuData => {
                if (menuData && menuData.length > 0) {
                    loadMenu(menuData);
                }
            });
        }
        // Call this function when the page loads
        window.addEventListener('DOMContentLoaded', (event) => {
            initializeMenu();
        });


        async function fetchAndParseMenuData() {
            try {
                //console.log("Fetching menu data...");
                const response = await fetch('https://raw.githubusercontent.com/Mischlichter/data/main/menu.txt');
                const text = await response.text();
                return parseMenuText(text);
            } catch (error) {
                console.error("Error fetching menu data:", error);
                return [];
            }
        }

        function parseMenuText(text) {
            //console.log("Parsing menu text...");
            let menuItems = text.split('\n').filter(line => line.trim() !== '');
            return menuItems.map(item => {
                let [label, scene] = item.split(':');
                return { label, scene };
            });
        }

        let menuContainerIds = []; // Global or accessible scope
        

        function loadMenu(menuData) {
       
            isAnimating = true;
            
            setTimeout(() => {
                isAnimating = false;
                
            }, 7000); // 3000 milliseconds = 3 seconds
            
            
            // Create or clear the menu bar
            let menuBar = document.querySelector('.menu-bar');
            if (!menuBar) {
                menuBar = document.createElement('div');
                menuBar.className = 'menu-bar';
                document.body.appendChild(menuBar);
            } else {
                menuBar.innerHTML = ''; // Clear existing content
            }

        // Insert logo image at the start of the menu bar
            const logoImg = document.createElement('img');
            logoImg.src = 'https://raw.githubusercontent.com/Mischlichter/data/main/interface/logo.png';
            logoImg.style.marginRight = '20px';
            logoImg.id = 'menuLogo'; // Assign an ID for easy reference
            menuBar.appendChild(logoImg);

            // Clear existing menu container IDs
            menuContainerIds = [];

            // Create new containers for each menu item
            menuData.forEach((menuItem, index) => {
                //console.log("Creating container for:", menuItem.label);
                const menuContainer = document.createElement('div');
                menuContainer.id = `menuContainer${index}`;
                menuContainer.className = 'menu-container';
                menuContainer.innerText = menuItem.label; // Display the label
                menuBar.appendChild(menuContainer); // Append to the menu bar

                // Add click event listener to load the corresponding scene
                menuContainer.addEventListener('click', () => {
                    currentSceneIndex = index; // Update the current scene index
                    loadScene(currentSceneIndex); // Load the selected scene
                    highlightActiveMenuItem(`menuContainer${index}`);
                });
                // Add hover event listener
                document.querySelectorAll('.menu-container').forEach(item => {
                    item.addEventListener('mouseover', () => animateTextDuringHover(item));
                });
                // To trigger the hover effect on the first menu container after 3 seconds
                setTimeout(() => {
                    let firstMenuItem = document.getElementById('menuContainer0');
                    if (firstMenuItem) {
                        animateTextDuringHover(firstMenuItem);
                    }
                }, 8000); // 3000 milliseconds = 3 seconds
                // Add the new container ID to the array
                menuContainerIds.push(menuContainer.id);
            });

            // Call updateMenu at the end
            updateMenu(menuData);
            updateLogoVisibility();
        }

        function updateLogoVisibility() {
            const logoImg = document.getElementById('menuLogo');
            if (window.innerWidth <= 768) { // Assumes the menu becomes multi-line at 768px width
                logoImg.classList.add('hide-logo');
            } else {
                logoImg.classList.remove('hide-logo');
            }
        }

//////// ANIMATION MENU ///////

        function updateMenu(menuData) {
            //console.log("Updating menu...");
            preparedMenuItems = {}; // Resetting for the new menu

            
            menuData.forEach((menuItem, index) => {
                let containerId = `menuContainer${index}`;
                let textLines = menuItem.label.split('\n'); // Changed from menuItem.title to menuItem.label
                //console.log("Preparing menu item:", menuItem.label);
                let lineSpans = createSpansForMenu(containerId, textLines.join(' '));
                preparedMenuItems[containerId] = lineSpans;
            });

            // Resetting the current animation index for menu
            currentContainerIndex = 0;
            containerIds = Object.keys(preparedMenuItems);



            startAllMenuAnimations();


        }


        function createSpansForMenu(containerId, text) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            //console.log("Creating spans for menu:", containerId);

            let tempSpan = document.createElement('span');
            tempSpan.style.display = 'inline-block';
            tempSpan.style.visibility = 'hidden';
            document.body.appendChild(tempSpan);

            let style = window.getComputedStyle(container);
            let paddingAndBorder = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) +
                                   parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
            let availableWidth = container.clientWidth - paddingAndBorder - 5;

            let lines = [];
            let currentLine = '';
            text.split(' ').forEach(word => {
                let testLine = currentLine + word + ' ';
                tempSpan.innerText = testLine;

                if (tempSpan.offsetWidth > availableWidth && currentLine !== '') {
                    let lineContainer = createLineContainerForMenu(container, currentLine.trim());
                    lines.push(lineContainer);
                    currentLine = word + ' ';
                } else {
                    currentLine = testLine;
                }
            });

            if (currentLine.trim() !== '') {
                let lineContainer = createLineContainerForMenu(container, currentLine.trim());
                lines.push(lineContainer);
            }

            document.body.removeChild(tempSpan);
            return lines;
        }

        function createLineContainerForMenu(container, lineText) {
            let lineContainer = document.createElement('div');
            lineContainer.style.display = 'inline-block';
            lineContainer.style.width = '100%';
            container.appendChild(lineContainer);

            //console.log("Creating line container for:", lineText);

            lineText.split(' ').forEach(word => {
                if (word.trim() !== '') {
                    var wordSpan = document.createElement('span');
                    wordSpan.className = 'dynamic-text';
                    wordSpan.setAttribute('data-final-text', word);
                    wordSpan.style.opacity = '0';
                    lineContainer.appendChild(wordSpan);
                }
            });

            return lineContainer;

        }

        function startAnimationForMenuContainer(containerId) {
            ///console.log("Starting animation for container:", containerId);
            if (preparedMenuItems[containerId]) {
                startLineAnimation(preparedMenuItems[containerId]);
            } else {
                console.log("No prepared data for container:", containerId);
            }
        }


        function startAllMenuAnimations() {
            menuContainerIds.forEach(containerId => {
                startAnimationForMenuContainer(containerId);

            if (containerId === 'menuContainer0') {
                initializeFirstScene();
            }
            });
        }

        function initializeFirstScene() {
            currentSceneIndex = 0; // Set to the first scene
            loadScene(currentSceneIndex); // Load the first scene
        }


        function shuffleMenu() {
            let menuItems = document.querySelectorAll('.menu-container');
            
            menuItems.forEach(menuItem => {
                if (!menuItem.dataset.originalText) {
                    menuItem.dataset.originalText = menuItem.textContent;
                }
                //console.log("Original text:", menuItem.dataset.originalText); // Log original text
                animateMenuDuringScaling(menuItem, menuItem.dataset.originalText);
            });
        }


        function animateMenuDuringScaling(element, finalText) {
            var totalDuration = 300; // Total duration of the scrambling
            var randomStartDelay = Math.random() * 200; // Start scrambling with random delay
            var stopScramblingDelay = totalDuration - 200 + Math.random() * 400; // When to stop scrambling
            var startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                var progress = timestamp - startTime;

                if (progress < stopScramblingDelay) {
                    var scrambledText = generateRandomString(finalText.length);
                    element.textContent = scrambledText;
                    //console.log("Scrambled text:", scrambledText); // Log scrambled text
                    requestAnimationFrame(step);
                } else {
                    element.textContent = finalText;
                    element.style.opacity = '1';
                    //console.log("Final text set to:", element.textContent); // Log final text
                    if (progress >= totalDuration) {
                        element.removeAttribute('data-originalText'); // Clean up
                    }
                }
            }

            setTimeout(function() {
                requestAnimationFrame(step);
            }, randomStartDelay);
        }

        function animateTextDuringHover(element, finalDuration = 150) {
            // Check if an animation is in progress
            if (isAnimating) {
                ///console.log("Animation already in progress. Hover animation blocked.");
                return; // Exit the function if an animation is already happening
            }

            // Capture the original text only if it has not been stored yet
            if (!element.dataset.originalText) {
                element.dataset.originalText = element.textContent;
            }

            var originalText = element.dataset.originalText; // Use the stored original text

            var startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                var progress = timestamp - startTime;

                if (progress < finalDuration) {
                    // Scramble text
                    var scrambledText = generateRandomString(originalText.length);
                    element.textContent = scrambledText;
                    requestAnimationFrame(step);
                } else {
                    // Revert back to the original text
                    element.textContent = originalText;
                }
            }

            requestAnimationFrame(step);
        }

        // Attach the event listener to each menu item for hover animation
        document.querySelectorAll('.menu-container').forEach(item => {
            item.addEventListener('mouseover', () => animateTextDuringHover(item));
        });




        function highlightActiveMenuItem(activeMenuItemId) {
            // Remove active class from all menu items
            document.querySelectorAll('.menu-container').forEach(item => {
                item.classList.remove('active-menu-item');
            });

            // Add active class to the current menu item
            const activeItem = document.getElementById(activeMenuItemId);
            if (activeItem) {
                activeItem.classList.add('active-menu-item');
            }
        }

//////// SZENE LOADER /////////////////////////////////////////////////////////////////////////


        let currentSceneIndex = 0;
        let scenesData = [];
        let scenesiData = [];

        async function initialize() {
            scenesData = await fetchAndParseData();
            if (scenesData && scenesData.length > 0) {
                loadScene(currentSceneIndex);
            
            }
            scenesiData = await fetchImage();
            if (scenesiData && scenesiData.length > 0) {
                loadScene(currentSceneIndex);
            
            }

        }




        // Keep track of dynamically added style elements
        const dynamicStyles = [];

        function clearDynamicStyles() {
          dynamicStyles.forEach(style => style.remove());
          dynamicStyles.length = 0; // Clear the array
        }

        function loadScene(index) {
          
            

            const scene = scenesData[index];
            const sceneImages = scenesiData[index]; // Assuming scenesiData is structured similarly

            if (!scene) return;


            // Remove all existing containers and dynamic styles
            const existingContainers = document.querySelectorAll('.flex-container, .flex-icontainer');
            existingContainers.forEach(container => container.remove());

            // Clear dynamic styles
            clearDynamicStyles();

            loadInterface(index);


            let formattedSceneKey = scene.sceneKey.length === 6 ? `scene0${scene.sceneKey.charAt(5)}` : scene.sceneKey;

            // Update the iframe with the new scene
            updateIframe(formattedSceneKey);
            console.log('Formatted Scene Key:', formattedSceneKey);
            // Merge and sort text and image containers
            let combinedData = [];
            Object.keys(scene.containers).forEach(key => {
                combinedData.push({ type: 'text', key: key, content: scene.containers[key] });
            });

            if (sceneImages && sceneImages.images) {
                Object.keys(sceneImages.images).forEach(key => {
                    combinedData.push({ type: 'image', key: key, content: sceneImages.images[key] });
                });
            }

            combinedData.sort((a, b) => {
                let numA = parseInt(a.key.match(/\d+/)[0], 10);
                let numB = parseInt(b.key.match(/\d+/)[0], 10);
                return numA - numB || (a.type === 'text' ? -1 : 1);
            });

            // Create containers in sorted order
            combinedData.forEach(item => {
                if (item.type === 'text') {
                    const container = document.createElement('div');
                    container.id = item.key;
                    container.className = 'flex-container';
                    document.body.appendChild(container);

                    const style = document.createElement('style');
                    style.innerHTML = item.content.style;
                    document.head.appendChild(style);
                    dynamicStyles.push(style);
                } else {
                    const imageContainer = document.createElement('div');
                    imageContainer.id = item.key;
                    imageContainer.className = 'flex-icontainer';
                    document.body.appendChild(imageContainer);

                    if (item.content.style) {
                        const style = document.createElement('style');
                        style.innerHTML = item.content.style;
                        document.head.appendChild(style);
                        dynamicStyles.push(style);
                    }

                    const image = document.createElement('img');
                    image.src = item.content.src;
                    imageContainer.appendChild(image);
                }
            });

            currentSceneData = scene;

            // Update containers when loading a new scene
            updateAllContainers(scene);

            highlightActiveMenuItem(`menuContainer${index}`);
            observeImagesForAnimation();
            
        }

        function observeImagesForAnimation() {
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        entry.target.style.opacity = 1; // Trigger the fade-in animation
                    }
                });
            }, {
                threshold: 0.3 // This means the animation will start when 10% of the item is visible
            });

            const images = document.querySelectorAll('.flex-icontainer');
            images.forEach(image => observer.observe(image));
        }

        function createVerticalTiles_a(containerId, imageUrl, imageHeight) {
            const container = document.getElementById(containerId);
            container.innerHTML = ''; // Clear existing content

            // Assuming the container's height is directly based on its content (the images)
            // We calculate the number of tiles needed to fill the container plus one for overflow
            const numTiles = 11; // Since you mentioned wanting about 10 tiles

            for (let i = 0; i < numTiles; i++) {
                const img = document.createElement('img');
                img.src = imageUrl;
                img.style.position = 'absolute';
                img.style.top = `${i * imageHeight}px`;
                img.style.left = 0;
                img.style.width = '100%'; // Stretch the image to fill the container's width
                img.style.height = `${imageHeight}px`; // Set a fixed height for direct tiling
                container.appendChild(img);
                requestAnimationFrame(updateParallax);
                
                // This function needs to be called to update the virtual canvas size accordingly
                delayedVirtualCanvasUpdate();
            }
        }



        function createVerticalTiles_b(containerId, imageUrl, imageHeight) {
            const container = document.getElementById(containerId);
            container.innerHTML = ''; // Clear existing content

            // Assuming the container's height is directly based on its content (the images)
            // We calculate the number of tiles needed to fill the container plus one for overflow
            const numTiles = 11; // Since you mentioned wanting about 10 tiles

            for (let i = 0; i < numTiles; i++) {
                const img = document.createElement('img');
                img.src = imageUrl;
                img.style.position = 'absolute';
                img.style.top = `${i * imageHeight}px`;
                img.style.left = 0;
                img.style.width = '100%'; // Stretch the image to fill the container's width
                img.style.height = `${imageHeight}px`; // Set a fixed height for direct tiling
                container.appendChild(img);
                requestAnimationFrame(updateParallax);
                
                updateVirtualCanvasSize();
            }
        }

        function delayedVirtualCanvasUpdate() {
            // Delay the call to updateVirtualCanvasSize
            setTimeout(updateVirtualCanvasSize, 100); // Delay of 100 milliseconds
        }

        function loadInterface(currentSceneIndex) {
            // Extend: Function to ensure wrapper existence
            function ensureWrapperExistence(wrapperClass, contentStructure) {
                let wrapper = document.querySelector(`.${wrapperClass}`);
                if (!wrapper) {
                    wrapper = document.createElement('div');
                    wrapper.className = wrapperClass;
                    document.body.appendChild(wrapper); // Append wrapper to the body
                    wrapper.innerHTML = contentStructure; // Set the inner HTML as per the structure required
                }
            }

            // For scene index 3, remove the wrappers completely
            if (currentSceneIndex === 3 || currentSceneIndex === 4) {
                document.querySelectorAll('.scale-wrapper-background, .scale-wrapper-interface').forEach(wrapper => {
                    wrapper.parentNode.removeChild(wrapper);
                });
                return; // Exit the function after handling the special case for scene index 3
            }

            // Ensure the existence of `.scale-wrapper-background` and `.scale-wrapper-interface` wrappers
            ensureWrapperExistence('scale-wrapper-background', `
                <div id="backgroundRoot">
                    <div id="backgroundContainer">
                        <div id="backgroundInterfaceContainer">
                            <div id="interfaceBackground"></div>
                        </div>
                    </div>
                </div>
            `);

            ensureWrapperExistence('scale-wrapper-interface', `
                <div id="interfaceContainer">
                    <div id="interfaceSideLeft" class="sideImageContainer"></div>
                    <div id="interfaceViewerContainer">
                        <img id="interfaceViewerImage" alt="Viewer Image">
                    </div>
                    <div id="interfaceSideRight" class="sideImageContainer"></div>
                </div>
            `);

            // Your existing code to tile images and update the viewer image
            const sceneFormatted = currentSceneIndex.toString().padStart(2, '0');
            const imageHeight = 2048; // Fixed height for all images

            const backgroundUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/background/b${sceneFormatted}.png`;
            const sideImageUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/side/s${sceneFormatted}.png`;
            const viewerImageUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/viewer/v${sceneFormatted}.png`;
            const viewerMaskUrl = `https://raw.githubusercontent.com/Mischlichter/data/main/interface/viewer/viewermask.png`;

            createVerticalTiles_a('interfaceBackground', backgroundUrl, imageHeight);
            createVerticalTiles_b('interfaceSideLeft', sideImageUrl, imageHeight);
            createVerticalTiles_b('interfaceSideRight', sideImageUrl, imageHeight);

            const viewerImageElement = document.getElementById('interfaceViewerImage');
            if (viewerImageElement) {
                viewerImageElement.src = viewerImageUrl;
                viewerImageElement.style.maskImage = `url('${viewerMaskUrl}')`;
                viewerImageElement.style.webkitMaskImage = `url('${viewerMaskUrl}')`;
                viewerImageElement.style.maskSize = 'cover';
                viewerImageElement.style.webkitMaskSize = 'cover';
            }
        }

        let lastScrollY = 0;

        function updateParallax() {
            const speedFactorBackground = 0.3; // Slower background movement
            const speedFactorSides = -1.2; // Faster side images movement, negative for upward scroll
            const speedFactorViewer = -0.3; // Viewer image movement speed, matching scroll speed for a floating effect

            // Background parallax effect
            const background = document.getElementById('interfaceBackground');
            const offsetBackground = window.scrollY * speedFactorBackground;
            background.style.transform = `translateY(${offsetBackground}px)`;

            // Side images parallax effect - since the sides are dynamically created, target their containers
            const sideLeft = document.getElementById('interfaceSideLeft');
            const sideRight = document.getElementById('interfaceSideRight');
            const offsetSides = window.scrollY * speedFactorSides;
            sideLeft.style.transform = `translateY(${offsetSides}px)`;
            sideRight.style.transform = `translateY(${offsetSides}px)`;

            // Viewer image parallax effect - Apply the effect to the viewer container for more control
            const viewerContainer = document.getElementById('interfaceViewerContainer');
            const offsetViewer = window.scrollY * speedFactorViewer;
            viewerContainer.style.transform = `translateY(${offsetViewer}px)`;

            lastScrollY = window.scrollY; // Update the last scroll position

            requestAnimationFrame(updateParallax); // Continuously update the position
        }

        // Initialize everything after the page content is fully loaded
        window.addEventListener('load', () => {
            loadInterface(0); // Load with the initial scene index
            adjustScaleBasedOnAspectRatio();

            // Simple check for mobile devices and iOS platform
            if (!/Mobi|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                requestAnimationFrame(updateParallax);
            }
        });








/////////// ANIMATION TEXT /////

        function generateRandomString(length) {
            var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%&*()[]{}|';
            var randomString = '';
            for (var i = 0; i < length; i++) {
                randomString += characters.charAt(Math.floor(Math.random() * characters.length));
            }
            return randomString;
        }

        function animateText(element, finalText, duration, delay) {
            setTimeout(function() {
                var currentText = generateRandomString(finalText.length);
                element.textContent = currentText;
                element.style.opacity = '0';

                var shuffleFrequency = 20;
                var intervalTime = duration / (finalText.length * shuffleFrequency);
                var index = 0;
                var shuffleCount = 0;
                var startTime = null;

                function step(timestamp) {
                    if (!startTime) startTime = timestamp;
                    var progress = timestamp - startTime;

                    if (progress > intervalTime) {
                        if (shuffleCount % shuffleFrequency === 0 && index < finalText.length) {
                            currentText = currentText.substring(0, index) + finalText.charAt(index) + generateRandomString(finalText.length - index - 1);
                            index++;
                        } else {
                            currentText = currentText.substring(0, index) + generateRandomString(finalText.length - index);
                        }
                        element.textContent = currentText;
                        shuffleCount++;
                        element.style.opacity = Math.min(1, parseFloat(element.style.opacity) + 0.05);

                        let colorTransitionFactor = index / finalText.length;
                        let startColor = { r: 7, g: 247, b: 139 }; // #07f78b
                        let endColor = { r: 0, g: 255, b: 204 };   // #7cfc05
                        let r = Math.floor(startColor.r + (endColor.r - startColor.r) * colorTransitionFactor);
                        let g = Math.floor(startColor.g + (endColor.g - startColor.g) * colorTransitionFactor);
                        let b = Math.floor(startColor.b + (endColor.b - startColor.b) * colorTransitionFactor);
                        element.style.color = `rgb(${r}, ${g}, ${b})`;

                        if (index === finalText.length && shuffleCount % shuffleFrequency === 0) {
                            element.textContent = finalText;
                            element.style.opacity = '1';
                            element.style.color = `rgb(${endColor.r}, ${endColor.g}, ${endColor.b})`; // Final color
                            return; // Stop the animation
                        }
                        startTime = timestamp;
                    }
                    requestAnimationFrame(step);
                }

                requestAnimationFrame(step);
            }, delay);
        }

        function createSpansForContainer(containerId, text) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            let tempSpan = document.createElement('span');
            tempSpan.style.display = 'inline-block';
            tempSpan.style.visibility = 'hidden';
            document.body.appendChild(tempSpan);

            let style = window.getComputedStyle(container);
            let paddingAndBorder = parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) +
                                   parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth);
            let availableWidth = container.clientWidth - paddingAndBorder - 5;

            // Calculate 10% additional width
            let additionalWidth = availableWidth * 0.095;
            let extendedWidth = availableWidth + additionalWidth;

            let lines = [];
            let currentLine = '';
            text.split(' ').forEach(word => {
                let testLine = currentLine + word + ' ';
                tempSpan.innerText = testLine;

                // Use extendedWidth for the condition
                if (tempSpan.offsetWidth > extendedWidth && currentLine !== '') {
                    let lineContainer = createLineContainer(container, currentLine.trim());
                    lines.push(lineContainer);
                    currentLine = word + ' ';
                } else {
                    currentLine = testLine;
                }
            });

            if (currentLine.trim() !== '') {
                let lineContainer = createLineContainer(container, currentLine.trim());
                lines.push(lineContainer);
            }

            document.body.removeChild(tempSpan);
            return lines;
        }

        function createLineContainer(container, lineText) {
            adjustContainerSizesBasedOnVirtualCanvas();
            let lineContainer = document.createElement('div');
            lineContainer.style.display = 'inline-block';
            lineContainer.style.width = '1000%';
            container.appendChild(lineContainer);
            lineContainer.style.whiteSpace = 'nowrap';
            lineText.split(' ').forEach(word => {
                if (word.trim() !== '') {
                    var wordSpan = document.createElement('span');
                    wordSpan.className = 'dynamic-text';
                    wordSpan.setAttribute('data-final-text', word);
                    wordSpan.style.opacity = '0';
                    lineContainer.appendChild(wordSpan);
                }
            });

            return lineContainer;
        }

        function startLineAnimation(lineContainers) {
            let wordDelayIncrement = 200;
            let lineStartDelay = 300;

            // Pre-populate line containers with blank spaces or invisible characters
            lineContainers.forEach(lineContainer => {
                Array.from(lineContainer.children).forEach(wordSpan => {
                    wordSpan.textContent = '\u00A0'; // Non-breaking space
                });
            });

            // Start the animation by replacing the placeholders with actual text
            lineContainers.forEach((lineContainer, lineIndex) => {
                Array.from(lineContainer.children).forEach((wordSpan, wordIndex) => {
                    let totalDelay = (lineIndex * lineStartDelay) + (wordIndex * wordDelayIncrement);
                    setTimeout(() => {
                        animateText(wordSpan, wordSpan.getAttribute('data-final-text'), 1000);
                    }, totalDelay);
                });
            });
        }


////////ANIMATION SCALING

        let preparedContainers = {};

        function updateAllContainers(Scene) {

            preparedContainers = {}; // Resetting for the new Scene
            Object.keys(Scene.containers).forEach(containerId => {

                let containerData = Scene.containers[containerId];
                let textLines = containerData.text.split('\n');
                let lineSpans = createSpansForContainer(containerId, textLines.join(' '));
                preparedContainers[containerId] = lineSpans;
            });

            // Resetting the current animation index
            currentContainerIndex = 0;
            containerIds = Object.keys(Scene.containers);

        }

        function startAnimationForContainer(containerId) {
            //console.log("Starting animation for container:", containerId);
            if (preparedContainers[containerId]) {
                startLineAnimation(preparedContainers[containerId]);
            } else {
                console.log("No prepared data for container:", containerId);
            }
        }
      
        function checkAndInitialize() {
            const container01 = document.getElementById('container01');
            if (container01.clientWidth > 0) {
                updateAllContainers();
            } else {
                setTimeout(checkAndInitialize, 50);
            }
        }

        function animateTextDuringScaling(element, finalText) {
            var currentText = generateRandomString(finalText.length);
            element.textContent = currentText;
            element.style.opacity = '1';

            var totalDuration = 300;  // Total duration of the scrambling
            var randomStartDelay = Math.random() * 200;  // Start scrambling with random delay
            var stopScramblingDelay = totalDuration - 200 + Math.random() * 400;  // Stop scrambling with random delay
            var startTime = null;

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                var progress = timestamp - startTime;

                if (progress < stopScramblingDelay) {
                    currentText = generateRandomString(finalText.length);
                    element.textContent = currentText;
                    requestAnimationFrame(step);
                } else {
                    element.textContent = finalText;
                }
            }

            setTimeout(function() {
                requestAnimationFrame(step);
            }, randomStartDelay);
        }

        function startScalingAnimation(lineContainers) {
            lineContainers.forEach(lineContainer => {
                Array.from(lineContainer.children).forEach(wordSpan => {
                    animateTextDuringScaling(wordSpan, wordSpan.getAttribute('data-final-text'));
                });
            });
        }
 
        function updateAllContainersDuringScaling() {
            if (!currentSceneData) {
                return; // Exit if not set
            }
            const savedScrollPosition = window.scrollY;
            // Use currentSceneData for scaling animation
            Object.keys(currentSceneData.containers).forEach(containerId => {
                let containerData = currentSceneData.containers[containerId];
                let textLines = containerData.text.split('\n');
                let lineSpans = createSpansForContainer(containerId, textLines.join(' '));
                startScalingAnimation(lineSpans);
            });
            window.scrollTo(0, savedScrollPosition);
        }
        
        window.addEventListener('resize', function() {
            // Check if the device is iOS
            var iOS = /iPad|iPhone|iPod/.test(navigator.platform) || 
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

            // Exclude this code from running on iOS devices
            if(iOS) {
                return; // Exit the function if on an iOS device
            }

            if (isAnimating) {
                return; // Exit the function if an animation is already happening
            }
            updateAllContainersDuringScaling();
            
            shuffleMenu();
        });


        function checkAndStartAnimationsOnScroll() {
            const viewportHeight = window.innerHeight;
            const triggerHeight = viewportHeight / 1.3; // 1/4 of the viewport height

            containerIds.forEach(containerId => {
                const container = document.getElementById(containerId);
                if (container) {
                    const rect = container.getBoundingClientRect();
                    if (rect.top <= triggerHeight && !container.dataset.animationStarted) {
                        startAnimationForContainer(containerId);
                        container.dataset.animationStarted = 'true'; // Mark as animated
                    }
                }
            });
        }

        

        function getSmoothAspectRatio(viewportWidth, viewportHeight) {
            const portraitAspectRatio = 1.6; 
            const landscapeAspectRatio = 1.9; 

            const currentAspectRatio = viewportWidth / viewportHeight;

            if (currentAspectRatio < 1) {
                return portraitAspectRatio;
            } else if (currentAspectRatio >= 1 && currentAspectRatio < 4 / 3) {
                let t = (currentAspectRatio - 1) / (4 / 3 - 1);
                return portraitAspectRatio + t * (landscapeAspectRatio - portraitAspectRatio);
            } else {
                return landscapeAspectRatio;
            }
        }

        var lastScaleFactor = null; // Tracks the last scale factor for portrait mode
        var cumulativeScaleChange = 0; // Accumulates scale changes for portrait mode

        function updateVirtualCanvasSize() {
            var virtualcanvas = document.getElementById('virtualcanvas');
            if (!virtualcanvas) {
                virtualcanvas = document.createElement('div');
                virtualcanvas.id = 'virtualcanvas';
                document.body.appendChild(virtualcanvas);
                // Ensure elements are prepared for smooth transitions
                virtualcanvas.style.transition = 'transform 0.5s ease';
            }

            var viewportWidth = window.innerWidth;
            var viewportHeight = window.innerHeight;
            var isPortrait = viewportWidth < viewportHeight;
            var smoothAspectRatio = getSmoothAspectRatio(viewportWidth, viewportHeight);
            var fixedAspectRatio = 1536 / 1024; // Fixed aspect ratio

            var canvasWidth, canvasHeight;
            if (isPortrait) {
                canvasHeight = viewportHeight / smoothAspectRatio;
                canvasWidth = canvasHeight * fixedAspectRatio;
            } else {
                canvasWidth = viewportWidth;
                canvasHeight = canvasWidth / smoothAspectRatio;
            }

            var size = { width: canvasWidth, height: canvasHeight };

            var scaleFactor = Math.min(size.width / 1536, size.height / 1024);
            if (isPortrait) {
                // Adjust for portrait mode with threshold mechanics
                var threshold = 0.50; // Define the threshold for scale changes
                var scaleFactorChange = lastScaleFactor !== null ? Math.abs(scaleFactor - lastScaleFactor) : 0;
                cumulativeScaleChange += scaleFactorChange;

                if (cumulativeScaleChange < threshold && lastScaleFactor !== null) {
                    // If changes do not exceed the threshold, revert to the last scale factor
                    scaleFactor = lastScaleFactor;
                } else {
                    // Once threshold is exceeded, update normally and reset
                    lastScaleFactor = scaleFactor;
                    cumulativeScaleChange = 0; // Reset cumulative change after exceeding threshold
                }
            } else {
                // Landscape mode applies scale directly without threshold mechanics
                lastScaleFactor = null; // Reset for portrait mode tracking
                cumulativeScaleChange = 0; // Clear cumulative changes
            }

            // Apply the scale factor for all modes
            document.querySelectorAll('.scale-wrapper-background, .scale-wrapper-interface').forEach(element => {
                
                element.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
                
            });

            // Update the virtual canvas size
            virtualcanvas.style.width = size.width + 'px';
            virtualcanvas.style.height = size.height + 'px';
            virtualcanvas.style.left = '50%';
            virtualcanvas.style.position = 'absolute';
            virtualcanvas.style.transform = 'translate(-50%, -50%)';
            virtualcanvas.style.top = '50%';
            virtualcanvas.style.zIndex = '100';
        }

        function adjustContainerSizesBasedOnVirtualCanvas() {
            var virtualCanvas = document.getElementById('virtualcanvas');
            if (!virtualCanvas) {
                console.error('Virtual canvas not found.');
                return;
            }

            // Get the width of the virtual canvas
            var virtualCanvasWidth = virtualCanvas.offsetWidth;

            // Calculate the desired width as a percentage of the virtual canvas width
            var baseWidthPercent = 38; // The base width percentage for your design
            var scaledWidthPx = (virtualCanvasWidth * baseWidthPercent) / 100; // Calculate scaled width in pixels

            // Adjust the widths of .flex-container and .flex-icontainer
            var flexContainers = document.querySelectorAll('.flex-container, .flex-icontainer');
            flexContainers.forEach(function(container) {
                // Set width directly in pixels to match the calculated width based on virtual canvas
                container.style.width = scaledWidthPx + 'px';
                // For .flex-icontainer, set padding-top to maintain aspect ratio
                if (container.classList.contains('flex-icontainer')) {
                    container.style.paddingTop = scaledWidthPx + 'px';
                }
            });
        }

        let touchStartX = 0; // Initial touch position X
        let touchStartY = 0; // Initial touch position Y

        // Listen for the start of a touch and record its starting position
        document.addEventListener('touchstart', function(e) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
        }, { passive: true });

        // Listen for the move of a touch
        document.addEventListener('touchmove', function(e) {
            const touchCurrentX = e.touches[0].clientX;
            const touchCurrentY = e.touches[0].clientY;

            // Calculate the distance moved in both X and Y directions
            const moveX = touchCurrentX - touchStartX;
            const moveY = touchCurrentY - touchStartY;

            // Only prevent default horizontal scrolling behavior if horizontal movement is detected
            // and there is minimal vertical movement, to allow vertical scrolling
            if (Math.abs(moveX) > Math.abs(moveY)) {
                e.preventDefault();
            }
        }, { passive: false }); // 'passive: false' is needed to be able to call preventDefault



        // Add event listener to resize in case the viewport size changes
        window.addEventListener('resize', updateVirtualCanvasSize);

        window.addEventListener('scroll', checkAndStartAnimationsOnScroll);
        
        window.addEventListener('resize', updateLogoVisibility);


        initialize();
    </script>
</body>
</html>

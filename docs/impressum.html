<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arbitrage Trading App</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        h1 {
            text-align: center;
        }
        #wallets, #prices, #balances, #actions {
            margin: 20px 0;
        }
        .section {
            padding: 10px;
            border: 1px solid #ddd;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <h1>Arbitrage Trading App</h1>
    <div id="wallets" class="section">
        <button id="connectEth">Simulate MetaMask Connection</button>
        <button id="connectSol">Simulate Phantom Connection</button>
    </div>
    <div id="prices" class="section">
        <h2>Prices</h2>
        <p>Ethereum HOGE Price: <span id="ethPrice">0</span></p>
        <p>Solana HOGE Price: <span id="solPrice">0</span></p>
    </div>
    <div id="balances" class="section">
        <h2>Balances</h2>
        <p>Ethereum HOGE: <span id="ethHoge">1000</span></p>
        <p>Ethereum ETH: <span id="ethEth">10</span></p>
        <p>Solana HOGE: <span id="solHoge">1000</span></p>
        <p>Solana SOL: <span id="solSol">10</span></p>
    </div>
    <div id="actions" class="section">
        <h2>Actions</h2>
        <button id="simulate">Simulate Trade</button>
        <button id="execute">Execute Trade</button>
    </div>
    <script>
        let ethHoge = 1000;
        let ethEth = 10;
        let solHoge = 1000;
        let solSol = 10;
        const bridgeThreshold = 200;

        function updateBalances() {
            document.getElementById('ethHoge').textContent = ethHoge;
            document.getElementById('ethEth').textContent = ethEth;
            document.getElementById('solHoge').textContent = solHoge;
            document.getElementById('solSol').textContent = solSol;
        }

        async function fetchEthPrice() {
            const query = `
                {
                    token(id: "0xfad45e47083e4607302aa43c65fb3106f1cd7607") {
                        derivedETH
                    }
                    bundle(id: "1") {
                        ethPrice
                    }
                }
            `;
            const response = await fetch('https://api.thegraph.com/subgraphs/name/uniswap/uniswap-v2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ query })
            });
            const data = await response.json();
            const ethPrice = data.data.bundle.ethPrice;
            const hogeEth = data.data.token.derivedETH;
            return hogeEth * ethPrice;
        }

        async function fetchSolPrice() {
            const response = await fetch('https://serum-api.bonfida.com/candles/market_address?resolution=3600');
            const data = await response.json();
            return data.candles[0].close;
        }

        async function fetchPrices() {
            const ethPrice = await fetchEthPrice();
            const solPrice = await fetchSolPrice();

            document.getElementById('ethPrice').textContent = ethPrice.toFixed(4);
            document.getElementById('solPrice').textContent = solPrice.toFixed(4);

            return { ethPrice, solPrice };
        }

        function calculateFees() {
            const ethFee = 0.001;
            const solFee = 0.0001;
            const bridgeFee = 0.1;

            return { ethFee, solFee, bridgeFee };
        }

        function simulateTrade() {
            fetchPrices().then(({ ethPrice, solPrice }) => {
                const { ethFee, solFee, bridgeFee } = calculateFees();

                let tradeMessage = "No Arbitrage Opportunity";
                if (ethPrice < solPrice) {
                    const potentialProfit = (solPrice - ethPrice) * 100 - (ethFee + solFee + bridgeFee);
                    tradeMessage = `Arbitrage Opportunity: Buy on Ethereum, Sell on Solana. Potential Profit: ${potentialProfit.toFixed(4)}`;
                }

                console.log(tradeMessage);
                alert(tradeMessage);
            });
        }

        function executeTrade() {
            fetchPrices().then(({ ethPrice, solPrice }) => {
                const { ethFee, solFee, bridgeFee } = calculateFees();

                if (ethPrice < solPrice) {
                    const tradeAmount = 100;
                    ethHoge -= tradeAmount;
                    ethEth -= (tradeAmount * ethPrice + ethFee);
                    solHoge -= tradeAmount;
                    solSol += (tradeAmount * solPrice - solFee);

                    if (ethHoge - solHoge > bridgeThreshold) {
                        const bridgeAmount = (ethHoge - solHoge) / 2;
                        ethHoge -= bridgeAmount;
                        solHoge += bridgeAmount;
                        ethEth -= bridgeFee;
                    }

                    console.log('Executed trade: Bought on Ethereum, Sold on Solana');
                } else {
                    console.log('No Arbitrage Opportunity');
                }

                updateBalances();
            });
        }

        document.getElementById('connectEth').onclick = () => {
            console.log('Simulated MetaMask connected');
        };

        document.getElementById('connectSol').onclick = () => {
            console.log('Simulated Phantom connected');
        };

        document.getElementById('simulate').onclick = simulateTrade;
        document.getElementById('execute').onclick = executeTrade;

        setInterval(() => {
            fetchPrices();
        }, 5000);

        updateBalances();
    </script>
</body>
</html>
